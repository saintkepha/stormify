// Generated by CoffeeScript 1.8.0
(function() {
  var Promise, Yang, YangStorm;

  Yang = require('./yang/yang-core');

  Promise = require('promise');


  /**
   * `YangStorm` - provides ability to manage data models purely based on
   * schemas.  Does not handle any management of instantiated data model
   * records.  For data records collections and relationships management,
   * please refer to `DataStorm`.
   */

  YangStorm = Yang.define('module stormify-yang', {
    prefix: "stormy",
    organization: "ClearPath Networks NFV R&D Group",
    contact: 'Web:  <http://www.clearpathnet.com>\nCode: <http://github.com/stormstack/stormify>\n\nAuthor: Peter K. Lee <mailto:plee@clearpathnet.com>',
    description: "\nThis module contains RPC extensions for enabling stormify\nenabled data storm endpoints to auto-generate new YANG schema\nbased models into JavaScript class hierarchy and to dynamically\nderive REST-APIs to be served via 'stormify.express' mechanism.\n\nUsing this generator, a YANG module schema definition file can\nbe pushed to a stormify endpoint and that endpoint will auto\nconstruct the YANG module instance and be ready to accept REST\nAPI calls for manipulating the record properties and instances.\n\nThis generator is a built-in capability to stormify framework\nand usually the starting point before populating a target\nendpoint with data model records and associated RPC functions.\n",
    '2015-02-05': Yang.define('revision', {
      description: "Initial revision.",
      reference: "Proprietary"
    }),
    'stormify-data': Yang.define('include'),
    modules: Yang.define('container', {
      description: "Conceptual container showing all modules managed by this module",
      get: function() {
        return this.container._modules;
      },
      serialize: function() {
        return this.get().serialize();
      }
    }),
    'import-schema': Yang.define('rpc', {
      description: "\nPrimary routine for executing a request to import a YANG module\nschema to the target endpoint.\n\nResponds with JSON converted representation of YANG module\nschema upon success.\n",
      exec: function() {
        return this.importSchema.apply(this, arguments);
      }
    }),
    'export-schema': Yang.define('rpc', {
      description: "\nPrimary routine for executing a request to export YANG module\nschema from the target endpoint.\n\nResponds with YANG or JSON representation of matching YANG\nmodule's schema upon success depending on the specified HTTP\nheader.\n",
      exec: function() {
        return this.exportSchema.apply(this, arguments);
      }
    }),
    'import-rpc': Yang.define('rpc', {
      description: "\nSecondary routine for executing a request to import JS code\nfunctions representing RPC functionality to a previously\nimported YANG schema.\n\nThis operation should only take place between trusted systems\nsince it is possible arbitrary function can be executed,\nincluding crashing the receiving system.\n\nNo attempt will be made to qualify the code being pushed.\n\nThe input format MUST be JSON-formatted containing JS\nrepresented in string format as follows:\n\n{\n  module: 'some-name',\n  rpc: {\n    'rpc-name-1': 'function (hello) { return hello; }',\n    'rpc-name-2': 'function (bye) { return bye; }'\n  }\n  override: true/false\n}\n\nThe function(s) will be merged into the target module if found\nto have been auto-generated via a prior 'push-schema' rpc call.\n\nThe function(s) will have access to all the pre-existing\nfunctions within the module's instance space.  For details, be\nsure to review/understand the stormify data-storm class\nhierarchy for traversing/accessing properties within the given\nmodule.\n",
      exec: function() {
        return this.importRPC.apply(this, arguments);
      }
    }),
    'export-rpc': Yang.define('rpc', {
      description: "\nSecondary routine for executing a request to export JS code\nfunctions representing RPC functionality from a previously\nimported YANG schema.\n",
      exec: function() {
        return this.exportRPC.apply(this, arguments);
      }
    }),

    /*
     * END OF YANG SCHEMA
     *
     * below contains custom routines for supporting the RPC operation
     */
    importSchema: function(payload, encoding) {
      if (encoding == null) {
        encoding = 'yang';
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var Module, needle;
          if (typeof payload !== 'string') {
            if (/\b((?=[a-z0-9-]{1,63}\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}\b/.test(payload.url)) {
              needle = require('needle');
              return needle.get(payload.url, function(err, res) {
                var Module;
                Module = Yang.generate(res.body);
                _this._modules.register(Module);
                return resolve(Module);
              });
            } else {
              return reject('invalid url');
            }
          } else {
            Module = Yang.generate(payload);
            _this._modules.register(Module);
            return resolve(Module);
          }
        };
      })(this));
    },
    exportSchema: function(payload, encoding) {
      var Module, err, target, _ref;
      if (encoding == null) {
        encoding = 'yang';
      }
      try {
        target = (_ref = payload != null ? payload.module : void 0) != null ? _ref : payload;
        Module = (this._modules.contains(target)).model;
        switch (encoding) {
          case 'yang':
            return Module.toYANG();
          case 'json':
            return Module.toJSON('yang');
        }
      } catch (_error) {
        err = _error;
        console.log("WARNING: unable to retrieve schema from requested module: " + target);
        throw err;
      }
    },
    importRPC: function(payload) {
      var Module, RemoteProcedure, err, k, target, v, _ref, _ref1, _results;
      try {
        target = (_ref = payload != null ? payload.module : void 0) != null ? _ref : payload;
        Module = (this._modules.contains(target)).model;
        _ref1 = payload.rpc;
        _results = [];
        for (k in _ref1) {
          v = _ref1[k];
          RemoteProcedure = Module.prototype[k];
          if ((RemoteProcedure.get('yang')) !== 'rpc') {
            continue;
          }
          if (RemoteProcedure.prototype.exec instanceof Function) {
            if (payload.override !== true) {
              throw new Error("attempting to import over pre-existing RPC definition");
            }
          }
          _results.push(RemoteProcedure.include({
            exec: eval("(" + v + ")")
          }));
        }
        return _results;
      } catch (_error) {
        err = _error;
        console.log("WARNING: unable to import RPC to requested module: " + target);
        throw err;
      }
    },
    exportRPC: function(payload) {
      var Module, err, k, reply, target, v, _ref, _ref1;
      try {
        target = (_ref = payload != null ? payload.module : void 0) != null ? _ref : payload;
        Module = (this._modules.contains(target)).model;
        reply = {
          rpc: {}
        };
        _ref1 = Module.prototype;
        for (k in _ref1) {
          v = _ref1[k];
          if ((typeof v.get === "function" ? v.get('yang') : void 0) === 'rpc') {
            reply.rpc[k] = v.toSource();
          }
        }
        return reply;
      } catch (_error) {
        err = _error;
        console.log("WARNING: unable to export RPC from requested module: " + target);
        throw err;
      }
    }
  });

  module.exports = YangStorm;

}).call(this);
