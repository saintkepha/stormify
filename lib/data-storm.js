// Generated by CoffeeScript 1.8.0
(function() {
  var DataStorm, DataStormModel, DataStormRegistry, DataStormView, EventEmitter, SR, assert, bunyan,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  assert = require('assert');

  bunyan = require('bunyan');

  SR = require('./stormregistry');

  DataStormRegistry = (function(_super) {
    __extends(DataStormRegistry, _super);

    function DataStormRegistry(collection, opts) {
      var _ref;
      this.collection = collection;
      this.store = opts != null ? opts.store : void 0;
      assert((this.store != null) && this.store.contains(this.collection), "cannot construct DataStoreRegistry without valid store containing '" + collection + "' passed in");
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.entity = this.store.contains(this.collection);
      this.on('load', function(key, val) {
        var entry;
        this.log.debug({
          entity: this.entity.name,
          key: key
        }, 'loading a persisted record');
        entry = val != null ? val[this.entity.name] : void 0;
        if (entry != null) {
          entry.id = key;
          entry.saved = true;
          return this.add(key, entry);
        }
      });
      this.on('ready', function() {
        var size, _ref1;
        size = (_ref1 = Object.keys(this.entries)) != null ? _ref1.length : void 0;
        return this.log.info({
          entity: this.entity.name,
          size: size
        }, "registry for '" + this.collection + "' initialized with " + size + " records");
      });
      DataStormRegistry.__super__.constructor.call(this, {
        log: this.log,
        path: (opts != null ? opts.persist : void 0) ? "" + this.store.datadir + "/" + this.collection + ".db" : void 0
      });
    }

    DataStormRegistry.prototype.keys = function() {
      return Object.keys(this.entries);
    };

    DataStormRegistry.prototype.get = function(id) {
      var entry, err, record;
      entry = DataStormRegistry.__super__.get.call(this, id);
      if (entry == null) {
        return null;
      }
      if (!(entry instanceof DataStoreModel)) {
        this.log.debug({
          id: id
        }, "restoring " + this.entity.name + " from registry using underlying entry");
        try {
          record = this.store.createRecord(this.entity.name, entry);
          record.isSaved = true;
          this.update(id, record, true);
        } catch (_error) {
          err = _error;
          this.log.warn({
            method: 'get',
            id: id,
            error: err
          }, "issue while trying to restore a record of '" + this.entity.name + "' from registry");
          return null;
        }
      }
      return DataStormRegistry.__super__.get.call(this, id);
    };

    DataStormRegistry.prototype.update = function(key, entry, suppress) {
      DataStormRegistry.__super__.update.call(this, key, entry, true);
      if (suppress !== true) {
        this.emit('updated', entry, entry.dirtyProperties());
      }
      return entry;
    };

    return DataStormRegistry;

  })(SR);

  EventEmitter = require('events').EventEmitter;

  DataStormView = (function() {
    var extend;

    extend = require('util')._extend;

    function DataStormView(store, requestor) {
      var _ref;
      this.store = store;
      this.requestor = requestor;
      assert(store instanceof DataStore, "cannot provide View without valid DataStore");
      this.entities = extend({}, this.store.entities);
      this.log = (_ref = this.store.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
    }

    DataStormView.prototype.createRecord = function() {
      var args, record;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      record = this.store.createRecord.apply(this, args);
      return record;
    };

    DataStormView.prototype.deleteRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.deleteRecord.apply(this, args);
    };

    DataStormView.prototype.updateRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.updateRecord.apply(this, args);
    };

    DataStormView.prototype.findRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.findRecord.apply(this, args);
    };

    DataStormView.prototype.findBy = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.findBy.apply(this, args);
    };

    DataStormView.prototype.find = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.find.apply(this, args);
    };

    return DataStormView;

  })();

  DataStormModel = require('./data-storm-model');

  DataStorm = (function(_super) {
    __extends(DataStorm, _super);

    DataStorm.Model = DataStormModel;

    DataStorm.prototype.logfile = DataStorm.attr('string', {
      defaultValue: DataStorm.computed(function() {
        return "/tmp/" + this._name + "-" + (this.get('id')) + ".log";
      })
    });

    DataStorm.prototype.loglevel = DataStorm.attr('string', {
      defaultValue: 'info'
    });

    DataStorm.prototype.datadir = DataStorm.attr('string', {
      defaultValue: '/tmp'
    });

    DataStorm.prototype.models = DataStorm.computed((function() {
      var k, v, _ref, _results;
      _ref = this._models;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push({
          name: k,
          numRecords: Object.keys(v.records).length
        });
      }
      return _results;
    }));

    function DataStorm() {
      DataStorm.__super__.constructor.apply(this, arguments);

      /*
       *@authorizer = opts?.authorizer
      
      console.log "initializing a new DataStore: #{@name}"
      @log.info method:'constructor', 'initializing a new DataStore: %s', @name
      for name,prop of @properties
        continue unless prop.model? and prop.mode is 2
      
        do (name,prop) =>
          prop.registry ?= new DataStoreRegistry name, log:@log,store:@,persist:prop.opts?.persist
          if entity.static?
              entity.registry.once 'ready', =>
                  @log.info collection:collection, 'loading static records for %s', collection
                  count = 0
                  for entry in entity.static
                      entry.saved = true
                      if entity.persist is false or not entity.registry.get(entry.id)?
                          entity.registry.add entry.id, entry
                          count++
                  @log.info collection:collection, "autoloaded #{count}/#{entity.static.length} static records"
      
      @log.info method:'initialize', 'initialization complete for: %s', @name
      console.log "initialization complete for: #{@name}"
      @isReady = true
       * this is not guaranteed to fire when all the registries have been initialized
      process.nextTick => @emit 'ready'
       */
    }

    DataStorm.prototype.open = function(requestor) {
      return new DataStormView(this, requestor);
    };

    DataStorm.prototype.when = function(collection, event, callback) {
      var entity, _store;
      entity = this.contains(collection);
      assert((entity != null) && (entity.registry != null) && (event === 'added' || event === 'updated' || event === 'removed') && (callback != null), "must specify valid collection with event and callback to be notified");
      _store = this;
      return entity.registry.once('ready', function() {
        return this.on(event, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return process.nextTick(function() {
            return callback.apply(_store, args);
          });
        });
      });
    };

    DataStorm.prototype.findRecord = function(type, id) {
      var _ref;
      return (_ref = this.modelFor(type)) != null ? _ref.records[id] : void 0;
    };

    DataStorm.prototype.deleteRecord = function(type, id) {
      var _ref;
      return (_ref = this.findRecord(type, id)) != null ? _ref.destroy() : void 0;
    };

    DataStorm.prototype.updateRecord = function(type, id, data) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this.findRecord(type, id)) != null ? _ref1.setProperties(data) : void 0) != null ? _ref.save() : void 0;
    };

    DataStorm.prototype.find = function(type, query) {
      var k, records, v, _ref, _results, _results1;
      records = (_ref = this.modelFor(type)) != null ? _ref.records : void 0;
      if (records == null) {
        return null;
      }
      switch (false) {
        case !(query instanceof Array):
          _results = [];
          for (k in records) {
            v = records[k];
            if (__indexOf.call(query, k) >= 0) {
              _results.push(v);
            }
          }
          return _results;
        case !(query instanceof Object):
          return ((function() {
            var _results1;
            _results1 = [];
            for (k in records) {
              v = records[k];
              _results1.push(v);
            }
            return _results1;
          })()).filter(function(e) {
            return e.match(query);
          });
        case query == null:
          return records[query];
        default:
          _results1 = [];
          for (k in records) {
            v = records[k];
            _results1.push(v);
          }
          return _results1;
      }
    };

    DataStorm.prototype.commit = function(record) {
      var action, exists, registry, _ref;
      if (!(record instanceof DataStoreModel)) {
        return;
      }
      this.log.debug({
        method: "commit",
        record: record != null ? record.id : void 0
      });
      registry = (_ref = this.entities[record.name]) != null ? _ref.registry : void 0;
      assert(registry != null, "cannot commit '" + record.name + "' into store which doesn't contain the collection");
      action = (function() {
        switch (false) {
          case !record.isDestroy:
            registry.remove(record.id);
            return 'removed';
          case !!record.isSaved:
            exists = (record.id != null) && (registry.get(record.id) != null);
            assert(!exists, "cannot commit a new record '" + record.name + "' into the store using pre-existing ID: " + record.id);
            registry.add(record.id, record);
            return 'added';
          case !record.isDirty():
            record.changed = true;
            registry.update(record.id, record);
            delete record.changed;
            return 'updated';
        }
      })();
      if (action != null) {
        this.emit('commit', [action, record.name, record.id]);
        return this.log.info({
          method: "commit",
          id: record.id
        }, "" + action + " '%s' on the store registry", record.constructor.name);
      }
    };

    return DataStorm;

  })(DataStormModel);

  module.exports = DataStorm;

}).call(this);
