// Generated by CoffeeScript 1.8.0
(function() {
  var StormClass, StormObject, YangContainer, YangCoreEngine, YangExtension, YangGrouping, YangList, YangListEntry, YangModule, YangObject, YangParser, YangProperty, YangRemoteProcedure, YangSpec, assert, toSource,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  StormClass = require('../storm/storm-class');

  StormObject = require('../storm/storm-object');

  YangModule = require('./yang-module');

  YangObject = (function(_super) {
    __extends(YangObject, _super);

    function YangObject() {
      return YangObject.__super__.constructor.apply(this, arguments);
    }

    return YangObject;

  })(StormObject);


  /**
   * `YangGrouping` is purely a logical schema abstraction to allow
   * "tagging" of sections of schema for reference use by other YANG
   * schemas.
   *
   * So although we do create a `StormObject` mapping within the class
   * hierarchy of the overall `YangModel`, it should not be directly
   * referenced as property setter/getter.
   */

  YangGrouping = (function(_super) {
    __extends(YangGrouping, _super);

    function YangGrouping() {
      return YangGrouping.__super__.constructor.apply(this, arguments);
    }

    return YangGrouping;

  })(YangObject);

  YangContainer = (function(_super) {
    __extends(YangContainer, _super);

    function YangContainer() {
      return YangContainer.__super__.constructor.apply(this, arguments);
    }

    return YangContainer;

  })(YangObject);

  YangExtension = (function(_super) {
    __extends(YangExtension, _super);

    function YangExtension() {
      return YangExtension.__super__.constructor.apply(this, arguments);
    }

    return YangExtension;

  })(YangObject);

  YangListEntry = (function(_super) {
    __extends(YangListEntry, _super);

    function YangListEntry() {
      return YangListEntry.__super__.constructor.apply(this, arguments);
    }

    return YangListEntry;

  })(YangObject);

  YangProperty = (function(_super) {
    __extends(YangProperty, _super);

    function YangProperty() {
      return YangProperty.__super__.constructor.apply(this, arguments);
    }

    return YangProperty;

  })(YangObject.Property);

  YangList = (function(_super) {
    __extends(YangList, _super);

    YangList.Entry = YangListEntry;

    function YangList(model, opts, obj) {
      this.model = model;
      YangList.__super__.constructor.call(this, 'array', opts, obj);
    }

    return YangList;

  })(YangProperty);

  toSource = require('tosource');

  YangRemoteProcedure = (function(_super) {
    __extends(YangRemoteProcedure, _super);

    function YangRemoteProcedure() {
      return YangRemoteProcedure.__super__.constructor.apply(this, arguments);
    }

    YangRemoteProcedure.toSource = function() {
      if (this.prototype.exec instanceof Function) {
        return toSource(this.prototype.exec);
      }
    };

    YangRemoteProcedure.prototype.exec = function() {
      throw new Error("cannot invoke RPC without function defined");
    };

    return YangRemoteProcedure;

  })(YangObject);

  YangSpec = require('./yang-core-spec-v1');

  YangParser = require('yang-parser');

  assert = require('assert');

  YangCoreEngine = (function(_super) {
    __extends(YangCoreEngine, _super);

    function YangCoreEngine() {
      return YangCoreEngine.__super__.constructor.apply(this, arguments);
    }

    YangCoreEngine.set({
      module: YangModule,
      grouping: YangGrouping,
      container: YangContainer,
      list: YangList,
      extension: YangExtension,
      leaf: YangProperty,
      'leaf-list': YangProperty,
      rpc: YangRemoteProcedure
    });

    YangCoreEngine.define = function(keyword, args) {
      var Override, functions, k, name, statics, v, _ref;
      _ref = keyword.split(' '), keyword = _ref[0], name = _ref[1];
      statics = {};
      functions = {};
      for (k in args) {
        v = args[k];
        if (v instanceof Function) {
          functions[k] = v;
        } else {
          statics[k] = v;
        }
      }
      Override = this.get(keyword);
      if ((Override != null) && (typeof Override.get === "function" ? Override.get('storm') : void 0)) {
        return (function(_super1) {
          __extends(_Class, _super1);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.set({
            yang: keyword
          });

          if (name != null) {
            _Class.set({
              name: name
            });
          }

          _Class.extend(statics);

          _Class.include(functions);

          return _Class;

        })(Override);
      } else {
        return (function(_super1) {
          __extends(_Class, _super1);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.set({
            yang: keyword
          });

          _Class.extend(statics);

          _Class.include(functions);

          return _Class;

        })(YangObject);
      }
    };

    YangCoreEngine.generate = function(schema, parser, map) {
      var statement;
      this.parser = parser != null ? parser : YangParser;
      this.map = map != null ? map : YangSpec;
      assert((schema != null) && typeof schema === 'string', "must pass in input schema text to process for YANG");
      statement = this.parser.parse(schema);
      assert((statement != null) && statement.kw === 'module', "must pass in YANG module schema definition");
      if (this.groupings == null) {
        this.groupings = {};
      }
      if (this.types == null) {
        this.types = {};
      }
      return this.processStatement(statement);
    };

    YangCoreEngine.resolve = function(grouping, props) {
      if (!this.groupings.hasOwnProperty(grouping)) {
        console.log("WARNING: trying to 'uses' using " + grouping + " identifier not found");
        return null;
      }
      return this.groupings[grouping];
    };

    YangCoreEngine.processStatement = function(statement, map) {
      var hasMany, importModule, includeModule, keyword, param, properties, resolveMap, results, subs, value;
      if (map == null) {
        map = this.map;
      }
      keyword = statement.kw, param = statement.arg, subs = statement.substmts;
      resolveMap = (function(_this) {
        return function(map, key) {
          var v, value, _ref;
          value = (_ref = map[key]) != null ? _ref : _this.map[key];
          switch (false) {
            case !(value instanceof Function):
              return value();
            case !(value instanceof Array):
              v = value[0];
              v = (function() {
                switch (false) {
                  case !(v instanceof Function):
                    return v();
                  default:
                    return v;
                }
              })();
              return {
                type: 'array',
                value: v
              };
            default:
              return value;
          }
        };
      })(this);
      map = resolveMap(map, keyword);
      if ((map != null ? map.type : void 0) === 'array') {
        hasMany = true;
        map = map.value;
      }
      if (map == null) {
        console.log("WARNING: unsupported YANG " + keyword + " found, ignoring...");
        return;
      }
      results = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = subs.length; _i < _len; _i++) {
          statement = subs[_i];
          _results.push(this.processStatement(statement, map));
        }
        return _results;
      }).call(this)).filter(function(e) {
        return (e != null) && (e.value != null);
      });
      if (!(results.length > 0)) {
        return {
          name: keyword,
          value: param
        };
      }
      properties = results.reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      if (keyword === 'module' || keyword === 'submodule') {
        return this.define("" + keyword + " " + param, properties);
      }
      importModule = function(module, opts) {
        return null;
      };
      includeModule = function(module, opts) {};
      value = (function() {
        switch (keyword) {
          case 'import':
            return importModule(param, properties);
          case 'include':
            return includeModule(param, properties);
          case 'uses':
            return this.resolve(param, properties);
          case 'extension':
          case 'grouping':
          case 'rpc':
            return this.define("" + keyword + " " + param, properties);
          default:
            return this.define(keyword, properties);
        }
      }).call(this);
      switch (keyword) {
        case 'grouping':
          this.groupings[param] = value;
          break;
        case 'extension':
          this.map[param] = this.map.container;
          break;
        case 'typedef':
          void 0;
          break;
        case 'list':
          value.set({
            type: this.define('container', properties)
          });
          break;
        case 'leaf':
        case 'leaf-list':
          value.set({
            type: properties.type
          });
      }
      return {
        name: param,
        value: value
      };
    };

    return YangCoreEngine;

  })(StormClass);

  module.exports = YangCoreEngine;

}).call(this);
