// Generated by CoffeeScript 1.8.0
(function() {
  var DataStore, DataStoreController, DataStoreModel, DataStoreRegistry, DataStoreView, EventEmitter, SR, assert, bunyan,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  assert = require('assert');

  bunyan = require('bunyan');

  SR = require('./stormregistry');

  DataStoreRegistry = (function(_super) {
    __extends(DataStoreRegistry, _super);

    function DataStoreRegistry(collection, opts) {
      var datadir, _ref, _ref1;
      this.collection = collection;
      this.store = opts != null ? opts.store : void 0;
      assert((this.store != null) && this.store.contains(this.collection), "cannot construct DataStoreRegistry without valid store containing '" + collection + "' passed in");
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.entity = this.store.contains(this.collection);
      this.on('load', function(key, val) {
        var entry;
        this.log.debug({
          entity: this.entity.name,
          key: key
        }, 'loading a persisted record');
        entry = val != null ? val[this.entity.name] : void 0;
        if (entry != null) {
          entry.id = key;
          entry.saved = true;
          return this.add(key, entry);
        }
      });
      this.on('ready', function() {
        var size, _ref1;
        size = (_ref1 = Object.keys(this.entries)) != null ? _ref1.length : void 0;
        return this.log.info({
          entity: this.entity.name,
          size: size
        }, "registry for '" + this.collection + "' initialized with " + size + " records");
      });
      datadir = (_ref1 = opts != null ? opts.datadir : void 0) != null ? _ref1 : '/tmp';
      DataStoreRegistry.__super__.constructor.call(this, {
        log: this.log,
        path: (opts != null ? opts.persist : void 0) ? "" + datadir + "/" + this.collection + ".db" : void 0
      });
    }

    DataStoreRegistry.prototype.keys = function() {
      return Object.keys(this.entries);
    };

    DataStoreRegistry.prototype.get = function(id) {
      var entry, err, record;
      entry = DataStoreRegistry.__super__.get.call(this, id);
      if (entry == null) {
        return null;
      }
      if (!(entry instanceof DataStoreModel)) {
        this.log.info({
          id: id
        }, "restoring " + this.entity.name + " from registry using underlying entry");
        try {
          record = this.store.createRecord(this.entity.name, entry);
          record.isSaved = true;
          this.update(id, record);
        } catch (_error) {
          err = _error;
          this.log.warn({
            method: 'get',
            id: id,
            error: err
          }, "issue while trying to restore a record of '" + this.entity.name + "' from registry");
          return null;
        }
      }
      return DataStoreRegistry.__super__.get.call(this, id);
    };

    return DataStoreRegistry;

  })(SR);

  DataStoreModel = (function(_super) {
    var async, extend, uuid;

    __extends(DataStoreModel, _super);

    DataStoreModel.attr = function(type, opts) {
      return {
        type: type,
        opts: opts
      };
    };

    DataStoreModel.belongsTo = function(model, opts) {
      return {
        mode: 1,
        model: model,
        opts: opts
      };
    };

    DataStoreModel.hasMany = function(model, opts) {
      return {
        mode: 2,
        model: model,
        opts: opts
      };
    };

    DataStoreModel.computed = function(func, opts) {
      return {
        computed: func,
        opts: opts
      };
    };

    DataStoreModel.computedHistory = function(model, opts) {
      return {
        mode: 3,
        model: model,
        opts: opts
      };
    };

    DataStoreModel.schema = {
      createdOn: DataStoreModel.attr('date'),
      modifiedOn: DataStoreModel.attr('date'),
      accessedOn: DataStoreModel.attr('date'),
      error: DataStoreModel.attr('object')
    };

    async = require('async');

    extend = require('util')._extend;

    uuid = require('node-uuid');

    DataStoreModel.prototype.schema = {};

    DataStoreModel.prototype.store = null;

    function DataStoreModel(data, opts) {
      var check, key, name, prop, val, violations, _ref, _ref1, _ref2, _ref3;
      this.isSaved = false;
      this.isDestroyed = false;
      this.store = opts != null ? opts.store : void 0;
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.log.debug({
        data: data
      }, "constructing " + this.name);
      this.useCache = opts != null ? opts.useCache : void 0;
      this.relations = {};
      this.properties = {};
      this.schema = extend(this.schema, DataStoreModel.schema);
      _ref1 = this.schema;
      for (key in _ref1) {
        val = _ref1[key];
        this.properties[key] = extend({}, val);
        if (val.model != null) {
          this.relations[key] = {
            type: (function() {
              switch (val.mode) {
                case 1:
                  return 'belongsTo';
                case 2:
                  return 'hasMany';
              }
            })(),
            model: val.model
          };
        }
      }
      this.id = data != null ? data.id : void 0;
      if (this.id == null) {
        this.id = uuid.v4();
      }
      if (this.version == null) {
        this.version = 1;
      }
      this.setProperties(data);
      violations = [];
      _ref2 = this.properties;
      for (name in _ref2) {
        prop = _ref2[name];
        if (prop.value == null) {
          prop.value = (function() {
            var _ref3, _ref4;
            switch (false) {
              case typeof ((_ref3 = prop.opts) != null ? _ref3.defaultValue : void 0) !== 'function':
                return prop.opts.defaultValue();
              default:
                return (_ref4 = prop.opts) != null ? _ref4.defaultValue : void 0;
            }
          })();
        }
        if (!prop.value) {
          if ((_ref3 = prop.opts) != null ? _ref3.required : void 0) {
            violations.push("'" + name + "' is required for " + this.constructor.name);
          }
        } else {
          check = (function() {
            switch (prop.type) {
              case 'string' || 'number' || 'boolean':
                return typeof prop.value === prop.type;
              case 'date':
                if (typeof prop.value === 'string') {
                  prop.value = new Date(prop.value);
                }
                return prop.value instanceof Date;
              case 'array':
                return prop.value instanceof Array;
              default:
                return true;
            }
          })();
          if ((prop.type != null) && !check) {
            violations.push("'" + name + "' must be a " + prop.type);
          }
          if ((prop.model != null) && prop.value instanceof Array && prop.mode !== 2) {
            violations.push("'" + name + "' cannot be an array of " + prop.model);
          }
        }
        if (prop.mode === 2) {
          if (prop.value == null) {
            prop.value = [];
          }
        }
      }
      this.log.debug("done constructing " + this.name);
      assert(violations.length === 0, violations);
    }

    DataStoreModel.prototype.serialize = function(opts) {
      var data, prop, result, x, y, _ref;
      assert(this.isDestroyed === false, "attempting to serialize a destroyed record");
      result = {
        id: this.id
      };
      _ref = this.properties;
      for (prop in _ref) {
        data = _ref[prop];
        if (!(data.value != null)) {
          continue;
        }
        x = data.value;
        result[prop] = (function() {
          var _i, _len, _results;
          switch (false) {
            case !(x instanceof DataStoreModel):
              if ((opts != null ? opts.embedded : void 0) === true) {
                return x.serialize();
              } else {
                return x.id;
              }
              break;
            case !(x instanceof Array):
              _results = [];
              for (_i = 0, _len = x.length; _i < _len; _i++) {
                y = x[_i];
                _results.push(y instanceof DataStoreModel ? y.id : y);
              }
              return _results;
              break;
            default:
              return x;
          }
        })();
      }
      if ((opts != null ? opts.tag : void 0) !== true) {
        return result;
      }
      data = {};
      data["" + this.name] = result;
      return data;
    };

    DataStoreModel.prototype.get = function() {
      var cacheComputed, cachedFor, callback, enforce, enforceCheck, err, opts, prop, property, value, _i, _ref, _ref1;
      property = arguments[0], opts = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
      assert(this.properties.hasOwnProperty(property), "attempting to retrieve '" + property + "' which doesn't exist in this model");
      assert(this.isDestroyed === false, "attempting to retrieve '" + property + "' from a destroyed record");
      prop = this.properties[property];
      enforceCheck = opts.length ? opts[0].enforce : true;
      enforce = function(x) {
        var id, record, results, val, validator, violations, _ref;
        if (!enforceCheck) {
          return x;
        }
        this.log.debug("checking " + property + " with " + x);
        if (x == null) {
          x = (function() {
            var _ref, _ref1;
            switch (false) {
              case typeof ((_ref = prop.opts) != null ? _ref.defaultValue : void 0) !== 'function':
                return prop.opts.defaultValue();
              default:
                return (_ref1 = prop.opts) != null ? _ref1.defaultValue : void 0;
            }
          })();
        }
        violations = [];
        validator = prop != null ? (_ref = prop.opts) != null ? _ref.validator : void 0 : void 0;
        val = (function() {
          var _ref1, _ref2, _ref3;
          switch (false) {
            case !(x == null):
              if ((_ref1 = prop.opts) != null ? _ref1.required : void 0) {
                violations.push("'" + property + "' is a required property for " + this.name);
              }
              return x;
            case !((prop.model != null) && typeof prop.model !== 'string'):
              if (!(x instanceof prop.model)) {
                violations.push("'" + property + "' must be an instance of " + ((_ref2 = prop.model.prototype) != null ? (_ref3 = _ref2.constructor) != null ? _ref3.name : void 0 : void 0));
              }
              switch (prop.mode) {
                case 1:
                  return x;
                case 2:
                  return [x];
              }
              break;
            case !((prop.model != null) && x instanceof Array && prop.mode === 2):
              results = ((function() {
                var _j, _len, _ref4, _results;
                if (!(id instanceof DataStoreModel)) {
                  _ref4 = prop.value;
                  _results = [];
                  for (_j = 0, _len = _ref4.length; _j < _len; _j++) {
                    id = _ref4[_j];
                    _results.push(this.store.findRecord(prop.model, id));
                  }
                  return _results;
                }
              }).call(this)).filter(function(e) {
                return e != null;
              });
              if (results.length) {
                return results;
              } else {
                return x;
              }
              break;
            case !((prop.model != null) && x instanceof DataStoreModel):
              switch (prop.mode) {
                case 1:
                  return x;
                case 2:
                  return [x];
              }
              break;
            case !((prop.model != null) && x instanceof Object):
              return x;
            case !((prop.model != null) && prop.mode !== 3):
              record = this.store.findRecord(prop.model, x);
              if (record == null) {
                violations.push("'" + property + "' must be a model of " + prop.model + ", unable to find using " + x);
              }
              switch (prop.mode) {
                case 1:
                  return record;
                case 2:
                  return [record];
                case 3:
                  return null;
              }
              break;
            case !(x instanceof Array && prop.opts.unique):
              return x.unique();
            default:
              return x;
          }
        }).call(this);
        assert(violations.length === 0, violations);
        if (validator != null) {
          return validator.call(this, val);
        } else {
          return val;
        }
      };
      if (typeof (prop != null ? prop.computed : void 0) === 'function' && this.store.isReady) {
        this.log.debug("issuing get on computed property: %s", property);
        value = prop.value = enforce.call(this, prop.value);
        if (value && this.useCache && prop.cachedOn && (((_ref = prop.opts) != null ? _ref.cache : void 0) !== false)) {
          cachedFor = (new Date() - prop.cachedOn) / 1000;
          if (cachedFor < this.useCache) {
            this.log.debug({
              method: 'get',
              property: property,
              id: this.id
            }, "returning cached value: " + value + " will refresh in " + (this.useCache - cachedFor) + " seconds");
            if (typeof callback === "function") {
              callback(null, value);
            }
            return value;
          } else {
            this.log.info({
              method: 'get',
              property: property,
              id: this.id
            }, "re-computing expired cached property (" + cachedFor + " secs > " + this.useCache + " secs)");
          }
        }
        this.log.debug({
          method: 'get',
          property: property,
          id: this.id
        }, "computing a new value!");
        cacheComputed = (function(_this) {
          return function(err, value) {
            if (!(err && _this.useCache)) {
              prop.value = value;
              prop.cachedOn = new Date();
            }
            return typeof callback === "function" ? callback(err, enforce.call(_this, value)) : void 0;
          };
        })(this);
        try {
          if ((_ref1 = prop.opts) != null ? _ref1.async : void 0) {
            prop.computed.apply(this, [cacheComputed, prop]);
          } else {
            value = prop.value = prop.computed.apply(this);
            if (typeof callback === "function") {
              callback(null, enforce.call(this, prop.value));
            }
          }
        } catch (_error) {
          err = _error;
          this.log.warn({
            method: 'get',
            property: property,
            id: this.id,
            error: err
          }, "issue during executing computed property");
          if (typeof callback === "function") {
            callback(null, err);
          }
        }
        return value;
      } else {
        this.log.debug("issuing get on static property: %s", property);
        if (this.store.isReady) {
          prop.value = enforce.call(this, prop != null ? prop.value : void 0);
        }
        value = prop.value;
        this.log.debug({
          method: 'get',
          property: property,
          id: this.id
        }, "issuing get on " + property + " with " + value);
        if (typeof callback === "function") {
          callback(null, value);
        }
        return value;
      }
    };

    DataStoreModel.prototype.getProperties = function(props, callback) {
      var property, self, start, tasks, value;
      if (typeof props === 'function') {
        callback = props;
        props = this.properties;
      } else {
        if ((props != null) && !(props instanceof Array)) {
          props = [props];
        }
        if (props == null) {
          props = this.properties;
        }
      }
      self = this;
      tasks = {};
      for (property in props) {
        value = props[property];
        if (typeof value.computed === 'function') {
          (function(property) {
            self.log.debug("scheduling task for computed property: " + property + "...");
            tasks[property] = function(callback) {
              return self.get(property, callback);
            };
            return self.log.debug("completed task for computed property: " + property + "...");
          })(property);
        }
      }
      start = new Date();
      return async.parallel(tasks, (function(_this) {
        return function(err, results) {
          var data, duration, statics;
          results.id = _this.id;
          _this.log.trace({
            method: 'getProperties',
            id: _this.id,
            results: results
          }, 'computed properties');
          statics = {};
          for (property in props) {
            data = props[property];
            if (!data.computed) {
              statics[property] = _this.get(property);
            }
          }
          _this.log.trace({
            method: 'getProperties',
            id: _this.id,
            statics: statics
          }, 'static properties');
          results = extend(statics, results);
          for (property in results) {
            if (property.indexOf('++') > 0) {
              delete results[property];
            }
          }
          duration = new Date() - start;
          if (duration > 1000) {
            _this.log.warn({
              method: 'getProperties',
              duration: duration,
              numComputed: Object.keys(tasks).length,
              id: _this.id,
              computed: Object.keys(tasks)
            }, "processing properties took " + duration + " ms exceeding threshold!");
          }
          _this.log.debug({
            method: 'getProperties',
            id: _this.id,
            results: Object.keys(results)
          }, 'final results before callback');
          return callback(results);
        };
      })(this));
    };

    DataStoreModel.prototype.set = function() {
      var ArrayEquals, cval, isDirty, nval, opts, prop, property, setting, value, _base, _i, _j, _len, _ref, _ref1, _ref2;
      property = arguments[0], opts = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), value = arguments[_i++];
      assert(this.isDestroyed === false, "attempting to set a value to a destroyed record");
      if ((this.schema != null) && !this.properties.hasOwnProperty(property)) {
        return;
      }
      if (typeof value === 'function') {
        if (property instanceof Array) {
          for (_j = 0, _len = property.length; _j < _len; _j++) {
            prop = property[_j];
            this.properties[prop] = {
              inherit: true
            };
          }
          property = property.join('++');
        }
        if ((_ref = this.properties[property]) != null) {
          _ref.computed = value;
        }
        return (_base = this.properties)[property] != null ? _base[property] : _base[property] = {
          computed: value
        };
      } else {
        ArrayEquals = function(a, b) {
          return a.length === b.length && a.every(function(elem, i) {
            return elem === b[i];
          });
        };
        cval = (_ref1 = this.properties[property]) != null ? _ref1.value : void 0;
        nval = value;
        isDirty = (function() {
          switch (false) {
            case !!this.properties.hasOwnProperty(property):
              return false;
            case cval !== nval:
              return false;
            case !(cval instanceof Array && nval instanceof Array):
              return !ArrayEquals(cval, nval);
            default:
              return true;
          }
        }).call(this);
        this.log.debug({
          method: 'set',
          property: property,
          id: this.id
        }, "compared " + property + " " + cval + " with " + nval + "... isDirty:" + isDirty);
        setting = {
          isDirty: isDirty,
          lvalue: cval,
          value: nval
        };
        if (this.properties.hasOwnProperty(property)) {
          if ((_ref2 = this.properties[property].opts) != null ? _ref2.required : void 0) {
            assert(value != null, "must set value for required property '" + property + "'");
          }
          return this.properties[property] = extend(this.properties[property], setting);
        } else {
          return this.properties[property] = setting;
        }
      }
    };

    DataStoreModel.prototype.setProperties = function(obj) {
      var property, value, _results;
      _results = [];
      for (property in obj) {
        value = obj[property];
        _results.push(this.set(property, value));
      }
      return _results;
    };

    DataStoreModel.prototype.update = function(data) {
      var _ref, _ref1;
      assert(this.isDestroyed === false, "attempting to update a destroyed record");
      if ((_ref = this.controller) != null) {
        if (typeof _ref.beforeUpdate === "function") {
          _ref.beforeUpdate(data);
        }
      }
      this.setProperties(data);
      return (_ref1 = this.controller) != null ? typeof _ref1.afterUpdate === "function" ? _ref1.afterUpdate(data) : void 0 : void 0;
    };

    DataStoreModel.prototype.dirtyProperties = function() {
      var data, prop, _ref, _results;
      _ref = this.properties;
      _results = [];
      for (prop in _ref) {
        data = _ref[prop];
        if (data.isDirty) {
          _results.push(prop);
        }
      }
      return _results;
    };

    DataStoreModel.prototype.clearDirty = function() {
      var data, prop, _ref, _results;
      _ref = this.dirtyProperties();
      _results = [];
      for (prop in _ref) {
        data = _ref[prop];
        _results.push(data.isDirty = false);
      }
      return _results;
    };

    DataStoreModel.prototype.isDirty = function(properties) {
      var dirty;
      dirty = this.dirtyProperties();
      if (properties == null) {
        return dirty.length > 0;
      }
      if (!(properties instanceof Array)) {
        properties = [properties];
      }
      dirty = dirty.join(' ');
      return properties.some(function(prop) {
        return ~dirty.indexOf(prop);
      });
    };

    DataStoreModel.prototype.removeReferences = function(model, isSaveAfter) {
      var err, key, relation, _ref, _ref1;
      if (!(model instanceof DataStoreModel)) {
        return;
      }
      _ref = this.relations;
      for (key in _ref) {
        relation = _ref[key];
        if (relation.model !== model.name) {
          continue;
        }
        this.log.debug({
          method: 'removeReferences',
          id: this.id
        }, "clearing " + key + "." + relation.type + " '" + relation.model + "' containing " + model.id + "...");
        try {
          switch (relation.type) {
            case 'belongsTo':
              if (((_ref1 = this.get(key)) != null ? _ref1.id : void 0) === model.id) {
                this.set(key, null);
              }
              break;
            case 'hasMany':
              this.set(key, this.get(key).without({
                id: model.id
              }));
          }
        } catch (_error) {
          err = _error;
          this.log.warn({
            method: 'removeReferences',
            error: err
          }, "issue encountered while attempting to clear " + this.name + "." + key + " where " + relation.model + "=" + model.id);
        }
      }
      if (isSaveAfter === true) {
        return this.save();
      }
    };

    DataStoreModel.prototype.save = function(callback) {
      var err, _ref, _ref1;
      assert(this.isDestroyed === false, "attempting to save a destroyed record");
      switch (false) {
        case callback == null:
          try {
            if ((_ref = this.controller) != null) {
              if (typeof _ref.beforeSave === "function") {
                _ref.beforeSave();
              }
            }
          } catch (_error) {
            err = _error;
            this.log.error({
              method: 'save',
              record: this.name,
              id: this.id,
              error: err
            }, 'failed to satisfy beforeSave controller calls');
            callback(err, null);
            throw err;
          }
          return this.getProperties((function(_this) {
            return function(props) {
              var _ref1, _ref2;
              if (props == null) {
                _this.log.error({
                  method: 'save',
                  id: _this.id
                }, 'failed to retrieve properties following save!');
                return callback('save failed to retrieve updated properties!', null);
              }
              _this.log.info({
                method: 'save',
                record: _this.name,
                id: _this.id
              }, "saving a 'new' record");
              try {
                if ((_ref1 = _this.store) != null) {
                  _ref1.commit(_this);
                }
                _this.clearDirty();
                _this.isSaved = true;
                if ((_ref2 = _this.controller) != null) {
                  if (typeof _ref2.afterSave === "function") {
                    _ref2.afterSave();
                  }
                }
                return callback(null, _this, props);
              } catch (_error) {
                err = _error;
                _this.log.error({
                  method: 'save',
                  record: _this.name,
                  id: _this.id,
                  error: err
                }, 'failed to commit record to the store!');
                callback(err, null);
                throw err;
              }
            };
          })(this));
        case !!this.isSaved:
          break;
        default:
          if ((_ref1 = this.store) != null) {
            _ref1.commit(this);
          }
          return this.clearDirty();
      }
    };

    DataStoreModel.prototype.destroy = function(callback) {
      var _ref, _ref1, _ref2;
      if ((_ref = this.controller) != null) {
        if (typeof _ref.beforeDestroy === "function") {
          _ref.beforeDestroy();
        }
      }
      this.isDestroy = true;
      if ((_ref1 = this.store) != null) {
        _ref1.commit(this);
      }
      if ((_ref2 = this.controller) != null) {
        if (typeof _ref2.afterDestroy === "function") {
          _ref2.afterDestroy();
        }
      }
      this.isDestroyed = true;
      return typeof callback === "function" ? callback(null, true) : void 0;
    };

    return DataStoreModel;

  })(SR.Data);

  EventEmitter = require('events').EventEmitter;

  DataStoreController = (function(_super) {
    __extends(DataStoreController, _super);

    function DataStoreController(opts) {
      var _ref;
      assert((opts != null) && opts.model instanceof DataStoreModel, "unable to create an instance of DS.Controller without underlying model!");
      this.model = opts.model;
      this.store = this.view = opts.view;
      this.log = (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
    }

    DataStoreController.prototype.beforeUpdate = function(data) {
      return this.emit('beforeUpdate', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.afterUpdate = function(data) {
      this.model.set('modifiedOn', new Date());
      return this.emit('afterUpdate', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.beforeSave = function() {
      var createdOn;
      this.emit('beforeSave', [this.model.name, this.model.id]);
      this.log.trace({
        method: 'beforeSave'
      }, 'we should auto resolve belongsTo and hasMany here...');
      createdOn = this.model.get('createdOn');
      if (createdOn == null) {
        this.model.set('createdOn', new Date());
        this.model.set('modifiedOn', new Date());
        return this.model.set('accessedOn', new Date());
      }
    };

    DataStoreController.prototype.afterSave = function() {
      return this.emit('afterSave', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.beforeDestroy = function() {
      var err, key, relation, target, _ref, _ref1, _results;
      this.emit('beforeDestroy', [this.model.name, this.model.id]);
      this.log.info({
        method: 'beforeDestroy',
        model: this.model.name,
        id: this.model.id
      }, 'invoking beforeDestroy to remove external references to this model');
      _ref = this.model.relations;
      _results = [];
      for (key in _ref) {
        relation = _ref[key];
        this.log.debug({
          method: 'beforeDestroy',
          key: key,
          relation: relation
        }, "checking " + key + "." + relation.type + " '" + relation.model + "'");
        try {
          switch (relation.type) {
            case 'belongsTo':
              _results.push((_ref1 = this.model.get(key)) != null ? typeof _ref1.removeReferences === "function" ? _ref1.removeReferences(this.model, true) : void 0 : void 0);
              break;
            case 'hasMany':
              _results.push((function() {
                var _i, _len, _ref2, _results1;
                _ref2 = this.model.get(key);
                _results1 = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  target = _ref2[_i];
                  _results1.push(target != null ? typeof target.removeReferences === "function" ? target.removeReferences(this.model, true) : void 0 : void 0);
                }
                return _results1;
              }).call(this));
              break;
            default:
              _results.push(void 0);
          }
        } catch (_error) {
          err = _error;
          _results.push(this.log.warn({
            method: 'beforeDestroy',
            key: key,
            relation: relation
          }, "ignoring relation to '" + key + "' that cannot be resolved"));
        }
      }
      return _results;
    };

    DataStoreController.prototype.afterDestroy = function() {
      return this.emit('afterDestroy', [this.model.name, this.model.id]);
    };

    return DataStoreController;

  })(EventEmitter);

  DataStoreView = (function() {
    var extend;

    extend = require('util')._extend;

    function DataStoreView(store, requestor) {
      var _ref;
      this.store = store;
      this.requestor = requestor;
      assert(store instanceof DataStore, "cannot provide View without valid DataStore");
      this.entities = extend({}, this.store.entities);
      this.log = (_ref = this.store.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
    }

    DataStoreView.prototype.createRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.createRecord.apply(this, args);
    };

    DataStoreView.prototype.deleteRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.deleteRecord.apply(this, args);
    };

    DataStoreView.prototype.updateRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.updateRecord.apply(this, args);
    };

    DataStoreView.prototype.findRecord = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.findRecord.apply(this, args);
    };

    DataStoreView.prototype.findBy = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.findBy.apply(this, args);
    };

    DataStoreView.prototype.find = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.store.find.apply(this, args);
    };

    return DataStoreView;

  })();

  DataStore = (function(_super) {
    var async, extend, uuid;

    __extends(DataStore, _super);

    DataStore.Model = DataStoreModel;

    DataStore.Controller = DataStoreController;

    DataStore.View = DataStoreView;

    DataStore.Registry = DataStoreRegistry;

    DataStore.attr = DataStore.Model.attr;

    DataStore.belongsTo = DataStore.Model.belongsTo;

    DataStore.hasMany = DataStore.Model.hasMany;

    DataStore.computed = DataStore.Model.computed;

    DataStore.computedHistory = DataStore.Model.computedHistory;

    async = require('async');

    uuid = require('node-uuid');

    extend = require('util')._extend;

    DataStore.prototype.name = null;

    DataStore.prototype.adapters = {};

    DataStore.prototype.adapter = function(type, module) {
      if ((type != null) && (module != null)) {
        return this.adapters[type] = module;
      }
    };

    DataStore.prototype.using = function(adapter) {
      return this.adapters[adapter];
    };

    function DataStore(opts) {
      var _ref;
      if (this.name == null) {
        this.name = opts != null ? opts.name : void 0;
      }
      assert(this.name != null, "cannot construct DataStore without naming this store!");
      this.log = opts != null ? (_ref = opts.auditor) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.collections = {};
      this.entities = {};
      if ((opts != null ? opts.entities : void 0) != null) {
        this.entities = extend(this.entities, opts.entities);
      }
      this.authorizer = opts != null ? opts.authorizer : void 0;
      this.isReady = false;
    }

    DataStore.prototype.initialize = function() {
      var collection, entity, _fn, _ref;
      if (this.isReady) {
        return;
      }
      console.log("initializing a new DataStore: " + this.name);
      this.log.info({
        method: 'initialize'
      }, 'initializing a new DataStore: %s', this.name);
      _ref = this.collections;
      _fn = (function(_this) {
        return function(collection, entity) {
          if (entity.registry == null) {
            entity.registry = new DataStoreRegistry(collection, {
              log: _this.log,
              store: _this,
              persist: entity.persist
            });
          }
          if (entity["static"] != null) {
            return entity.registry.once('ready', function() {
              var entry, _i, _len, _ref1;
              _this.log.info({
                collection: collection
              }, 'loading static records for %s', collection);
              _ref1 = entity["static"];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                entry = _ref1[_i];
                entry.saved = true;
                entity.registry.add(entry.id, entry);
              }
              return _this.log.info({
                collection: collection
              }, "autoloaded " + entity["static"].length + " static records");
            });
          }
        };
      })(this);
      for (collection in _ref) {
        entity = _ref[collection];
        _fn(collection, entity);
      }
      if (this.authorizer instanceof DataStore) {
        this.references(this.authorizer.contains('identities'));
        this.authorizer.references(this.contains('sessions'));
      }
      this.log.info({
        method: 'initialize'
      }, 'initialization complete for: %s', this.name);
      console.log("initialization complete for: " + this.name);
      this.isReady = true;
      return process.nextTick((function(_this) {
        return function() {
          return _this.emit('ready');
        };
      })(this));
    };

    DataStore.prototype.contains = function(collection, entity) {
      if (entity == null) {
        return this.collections[collection];
      }
      entity.name = entity.model.prototype.name;
      entity.container = this;
      if (entity.persist == null) {
        entity.persist = true;
      }
      if (entity.cache == null) {
        entity.cache = 1;
      }
      if (entity.controller == null) {
        entity.controller = DataStoreController;
      }
      entity.collection = collection;
      this.collections[collection] = this.entities[entity.name] = entity;
      return this.log.info({
        collection: collection
      }, "registered a collection of '" + collection + "' into the store");
    };

    DataStore.prototype.references = function(entity) {
      assert((entity.name != null) && entity.container instanceof DataStore, "cannot reference an entity that isn't contained by another store!");
      entity = extend({}, entity);
      entity.external = true;
      entity.persist = false;
      entity.cache = false;
      this.entities[entity.name] = entity;
      return this.log.info({
        reference: entity.name
      }, "registered a reference to '" + entity.name + "' into the store");
    };

    DataStore.prototype.open = function(requestor) {
      return new DataStoreView(this, requestor);
    };

    DataStore.prototype.when = function(collection, event, callback) {
      var entity;
      entity = this.contains(collection);
      assert((entity != null) && (entity.registry != null) && (event === 'added' || event === 'updated' || event === 'removed') && (callback != null), "must specify valid collection with event and callback to be notified");
      return entity.registry.once('ready', function() {
        return this.on(event, function(entry) {
          return process.nextTick(function() {
            return callback(entry);
          });
        });
      });
    };

    DataStore.prototype.createRecord = function(type, data) {
      var entity, err, record;
      this.log.debug({
        method: "createRecord",
        type: type,
        data: data
      });
      try {
        entity = this.entities[type];
        record = new entity.model(data, {
          store: entity.container,
          log: this.log,
          useCache: entity.cache
        });
        record.controller = new entity.controller({
          model: record,
          view: this,
          log: this.log
        });
        this.log.info({
          method: "createRecord",
          id: record.id
        }, 'created a new record for %s', record.constructor.name);
      } catch (_error) {
        err = _error;
        this.log.error({
          error: err
        }, "unable to instantiate a new DS.Model for " + type);
        throw err;
      }
      return record;
    };

    DataStore.prototype.deleteRecord = function(type, id, callback) {
      var match;
      match = this.findRecord(type, id);
      if (match == null) {
        callback(null);
      }
      return match.destroy(callback);
    };

    DataStore.prototype.updateRecord = function(type, id, data, callback) {
      var record;
      record = this.findRecord(type, id);
      if (record == null) {
        callback(null);
      }
      record.update(data);
      return record.save(callback);
    };

    DataStore.prototype.findRecord = function(type, id) {
      var _ref, _ref1, _ref2;
      if (!((type != null) && (id != null))) {
        return;
      }
      assert(((_ref = this.entities[type]) != null ? _ref.registry : void 0) instanceof DataStoreRegistry, "trying to findRecord for " + type + " without registry!");
      return (_ref1 = this.entities[type]) != null ? (_ref2 = _ref1.registry) != null ? _ref2.get(id) : void 0 : void 0;
    };

    DataStore.prototype.findBy = function(type, condition, callback) {
      var hit, query, records, results, _ref, _ref1;
      if (!((type != null) && typeof condition === 'object')) {
        return callback("invalid findBy query params!");
      }
      this.log.debug({
        method: 'findBy',
        type: type,
        condition: condition
      }, 'issuing findBy on requested entity');
      records = ((_ref = this.entities[type]) != null ? (_ref1 = _ref.registry) != null ? _ref1.list() : void 0 : void 0) || [];
      query = condition;
      hit = Object.keys(query).length;
      results = records.filter((function(_this) {
        return function(record) {
          var err, key, match, val, x;
          match = 0;
          for (key in query) {
            val = query[key];
            try {
              x = record.get(key);
            } catch (_error) {
              err = _error;
              _this.log.warn({
                method: 'findBy',
                type: type,
                id: record.id,
                error: err
              }, 'skipping bad record...');
              return false;
            }
            if (x === val || (x instanceof DataStoreModel && x.id === val)) {
              match += 1;
            }
          }
          if (match === hit) {
            return true;
          } else {
            return false;
          }
        };
      })(this));
      if (!((results != null ? results.length : void 0) > 0)) {
        this.log.debug({
          method: 'findBy',
          type: type,
          condition: query
        }, 'unable to find any records for the condition!');
      } else {
        this.log.debug({
          method: 'findBy',
          type: type,
          condition: query
        }, 'found %d matching results', results.length);
      }
      if (typeof callback === "function") {
        callback(null, results);
      }
      return results;
    };

    DataStore.prototype.find = function(type, query, callback) {
      var id, ids, results, self, tasks, _entity, _fn, _i, _len;
      _entity = this.entities[type];
      if (_entity == null) {
        return callback("DS: unable to find using unsupported type: " + type);
      }
      ids = (function() {
        var _ref;
        switch (false) {
          case !(query instanceof Array):
            return query;
          case !(query instanceof Object):
            results = this.findBy(type, query);
            return results.map(function(record) {
              return record.id;
            });
          case query == null:
            return [query];
          default:
            return (_ref = _entity.registry) != null ? _ref.keys() : void 0;
        }
      }).call(this);
      self = this;
      tasks = {};
      _fn = function(id) {
        return tasks[id] = function(callback) {
          var err, match;
          match = self.findRecord(type, id);
          if (!((match != null) && match instanceof DataStoreModel)) {
            return callback(null);
          }
          try {
            return match.getProperties(function(properties) {
              return callback(null, match);
            });
          } catch (_error) {
            err = _error;
            self.log.warn({
              error: err,
              type: type,
              id: id
            }, 'unable to obtain validated properties from the matching record');
            return callback(null);
          }
        };
      };
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        _fn(id);
      }
      this.log.debug({
        method: 'find',
        type: type,
        query: query
      }, 'issuing find on requested entity');
      return async.parallel(tasks, (function(_this) {
        return function(err, results) {
          var entry, key, matches;
          if (err != null) {
            _this.log.error(err, "error was encountered while performing find operation on " + type + " with " + query + "!");
            return callback(err);
          }
          matches = (function() {
            var _results;
            _results = [];
            for (key in results) {
              entry = results[key];
              if (entry != null) {
                _results.push(entry);
              }
            }
            return _results;
          })();
          if (!((matches != null ? matches.length : void 0) > 0)) {
            _this.log.debug({
              method: 'find',
              type: type,
              query: query
            }, 'unable to find any records matching the query!');
          } else {
            _this.log.debug({
              method: 'find',
              type: type,
              query: query
            }, 'found %d matching results', matches.length);
          }
          return callback(null, matches);
        };
      })(this));
    };

    DataStore.prototype.commit = function(record) {
      var action, exists, registry, _ref;
      if (!(record instanceof DataStoreModel)) {
        return;
      }
      this.log.debug({
        method: "commit",
        record: record
      });
      registry = (_ref = this.entities[record.name]) != null ? _ref.registry : void 0;
      assert(registry != null, "cannot commit '" + record.name + "' into store which doesn't contain the collection");
      action = (function() {
        switch (false) {
          case !record.isDestroy:
            registry.remove(record.id);
            return 'removed';
          case !!record.isSaved:
            exists = (record.id != null) && (registry.get(record.id) != null);
            assert(!exists, "cannot commit a new record '" + record.name + "' into the store using pre-existing ID: " + record.id);
            if (record.id == null) {
              record.id = uuid.v4();
            }
            registry.add(record.id, record);
            return 'added';
          case !record.isDirty():
            record.changed = true;
            registry.update(record.id, record);
            delete record.changed;
            return 'updated';
        }
      })();
      this.emit('commit', [action, record.name, record.id]);
      return this.log.info({
        method: "commit",
        id: record.id
      }, "" + action + " '%s' on the store registry", record.constructor.name);
    };

    DataStore.prototype.dump = function() {
      var entity, name, record, records, _ref, _ref1, _results;
      _ref = this.entities;
      _results = [];
      for (name in _ref) {
        entity = _ref[name];
        records = (_ref1 = entity.registry) != null ? _ref1.list() : void 0;
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = records.length; _i < _len; _i++) {
            record = records[_i];
            _results1.push(this.log.info({
              model: name,
              record: record.serialize(),
              method: 'dump'
            }, "DUMP"));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return DataStore;

  })(EventEmitter);

  module.exports = DataStore;

}).call(this);
