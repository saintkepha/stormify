// Generated by CoffeeScript 1.8.0
(function() {
  var DataStorm, StormModel, StormObject,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  StormModel = require('./storm/storm-model');

  StormObject = require('./storm/storm-object');

  DataStorm = (function(_super) {
    __extends(DataStorm, _super);

    function DataStorm() {
      return DataStorm.__super__.constructor.apply(this, arguments);
    }

    DataStorm.set({
      storm: 'ds'
    });

    DataStorm.extend(EventEmitter);

    DataStorm.Model = StormModel;

    DataStorm.Object = StormObject;

    DataStorm.prototype.loglevel = DataStorm.attr('string', {
      defaultValue: 'info'
    });

    DataStorm.prototype.datadir = DataStorm.attr('string', {
      defaultValue: '/tmp'
    });

    DataStorm.prototype.storms = DataStorm.hasMany(DataStorm, {
      "private": true
    });

    DataStorm.prototype.models = DataStorm.computed((function() {
      return this._models.serialize();
    }));


    /**
     * `addProperty` for DataStorm checks for new hasMany relationships
     * being added and registers the model to the private _models
     * registry and OVERRIDES the property to the corresponding
     * ModelRegistryProperty
     */

    DataStorm.prototype.addProperty = function(key, prop) {
      if (prop instanceof StormModel.Property && prop.kind === 'hasMany' && prop.opts["private"] !== true) {
        prop = this._models.register(prop.model, prop.opts);
      }
      return DataStorm.__super__.addProperty.call(this, key, prop);
    };


    /**
     * PUBLIC access methods for working directly with PRIVATE _models registry
     */

    DataStorm.prototype.create = function(type, data) {
      return null;
    };

    DataStorm.prototype.find = function(type, query) {
      return this._models.find(type, query);
    };

    DataStorm.prototype.update = function(type, id, data) {
      return null;
    };

    DataStorm.prototype["delete"] = function(type, query) {
      var model, _i, _len, _ref, _results;
      _ref = this.find(type, query);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        model = _ref[_i];
        _results.push(model.destroy());
      }
      return _results;
    };

    DataStorm.prototype.contains = function(key) {
      var prop;
      prop = this.getProperty(key);
      if (prop instanceof StormModel.Registry.Property) {
        return prop;
      }
    };

    DataStorm.prototype.infuse = function(opts) {
      return console.log("using: " + (opts != null ? opts.source : void 0));
    };

    DataStorm.prototype.open = function(requestor) {
      return new StormView(this, requestor);
    };

    DataStorm.prototype.when = function(collection, event, callback) {
      var entity, _store;
      entity = this.contains(collection);
      assert((entity != null) && (entity.registry != null) && (event === 'added' || event === 'updated' || event === 'removed') && (callback != null), "must specify valid collection with event and callback to be notified");
      _store = this;
      return entity.registry.once('ready', function() {
        return this.on(event, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return process.nextTick(function() {
            return callback.apply(_store, args);
          });
        });
      });
    };

    DataStorm.prototype.commit = function(record) {
      var action, exists, registry, _ref;
      if (!(record instanceof DataStoreModel)) {
        return;
      }
      this.log.debug({
        method: "commit",
        record: record != null ? record.id : void 0
      });
      registry = (_ref = this.entities[record.name]) != null ? _ref.registry : void 0;
      assert(registry != null, "cannot commit '" + record.name + "' into store which doesn't contain the collection");
      action = (function() {
        switch (false) {
          case !record.isDestroy:
            registry.remove(record.id);
            return 'removed';
          case !!record.isSaved:
            exists = (record.id != null) && (registry.get(record.id) != null);
            assert(!exists, "cannot commit a new record '" + record.name + "' into the store using pre-existing ID: " + record.id);
            registry.add(record.id, record);
            return 'added';
          case !record.isDirty():
            record.changed = true;
            registry.update(record.id, record);
            delete record.changed;
            return 'updated';
        }
      })();
      if (action != null) {
        this.emit('commit', [action, record.name, record.id]);
        return this.log.info({
          method: "commit",
          id: record.id
        }, "" + action + " '%s' on the store registry", record.constructor.name);
      }
    };

    return DataStorm;

  })(StormModel);

  module.exports = DataStorm;


  /*
       *@authorizer = opts?.authorizer
  
      console.log "initializing a new DataStore: #{@name}"
      @log.info method:'constructor', 'initializing a new DataStore: %s', @name
      for name,prop of @properties
        continue unless prop.model? and prop.mode is 2
  
        do (name,prop) =>
          prop.registry ?= new DataStoreRegistry name, log:@log,store:@,persist:prop.opts?.persist
          if entity.static?
              entity.registry.once 'ready', =>
                  @log.info collection:collection, 'loading static records for %s', collection
                  count = 0
                  for entry in entity.static
                      entry.saved = true
                      if entity.persist is false or not entity.registry.get(entry.id)?
                          entity.registry.add entry.id, entry
                          count++
                  @log.info collection:collection, "autoloaded #{count}/#{entity.static.length} static records"
  
      @log.info method:'initialize', 'initialization complete for: %s', @name
      console.log "initialization complete for: #{@name}"
      @isReady = true
       * this is not guaranteed to fire when all the registries have been initialized
      process.nextTick => @emit 'ready'
   */

}).call(this);
