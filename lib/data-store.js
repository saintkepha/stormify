// Generated by CoffeeScript 1.8.0
(function() {
  var DataStore, DataStoreController, DataStoreModel, DataStoreRegistry, EventEmitter, SR, assert, bunyan,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  assert = require('assert');

  bunyan = require('bunyan');

  SR = require('./stormregistry');

  DataStoreRegistry = (function(_super) {
    __extends(DataStoreRegistry, _super);

    function DataStoreRegistry(collection, opts) {
      var datadir, _ref, _ref1;
      this.collection = collection;
      this.store = opts != null ? opts.store : void 0;
      assert((this.store != null) && this.store.contains(this.collection), "cannot construct DataStoreRegistry without valid store containing '" + collection + "' passed in");
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.entity = this.store.contains(this.collection);
      this.on('load', function(key, val) {
        var entry;
        this.log.debug({
          entity: this.entity.name,
          key: key
        }, 'loading a persisted record');
        entry = val != null ? val[this.entity.name] : void 0;
        if (entry != null) {
          entry.id = key;
          entry.saved = true;
          return this.add(key, entry);
        }
      });
      this.on('ready', function() {
        var size, _ref1;
        size = (_ref1 = Object.keys(this.entries)) != null ? _ref1.length : void 0;
        return this.log.info({
          entity: this.entity.name,
          size: size
        }, "registry for '" + this.collection + "' initialized with " + size + " records");
      });
      datadir = (_ref1 = opts != null ? opts.datadir : void 0) != null ? _ref1 : '/tmp';
      DataStoreRegistry.__super__.constructor.call(this, {
        log: this.log,
        path: (opts != null ? opts.persist : void 0) ? "" + datadir + "/" + this.collection + ".db" : void 0
      });
    }

    DataStoreRegistry.prototype.keys = function() {
      return Object.keys(this.entries);
    };

    DataStoreRegistry.prototype.get = function(id) {
      var entry, record;
      entry = DataStoreRegistry.__super__.get.call(this, id);
      if (entry == null) {
        return null;
      }
      if (!(entry instanceof DataStoreModel)) {
        this.log.info({
          id: id
        }, "restoring " + this.entity.name + " from registry using underlying entry");
        record = this.store.createRecord(this.entity.name, entry);
        record.isSaved = true;
        this.update(id, record);
      }
      return DataStoreRegistry.__super__.get.call(this, id);
    };

    return DataStoreRegistry;

  })(SR);

  DataStoreModel = (function(_super) {
    var async, extend, uuid;

    __extends(DataStoreModel, _super);

    async = require('async');

    extend = require('util')._extend;

    uuid = require('node-uuid');

    DataStoreModel.prototype.schema = null;

    DataStoreModel.prototype.store = null;

    function DataStoreModel(data, opts) {
      var check, key, name, prop, val, violations, _ref, _ref1, _ref2, _ref3, _ref4;
      this.properties = {
        createdOn: {
          value: null
        },
        modifiedOn: {
          value: null
        },
        accessedOn: {
          value: null
        },
        error: {
          value: null
        }
      };
      this.isSaved = false;
      this.store = opts != null ? opts.store : void 0;
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.log.debug({
        data: data
      }, "constructing " + this.name);
      this.useCache = opts != null ? opts.useCache : void 0;
      _ref1 = this.schema;
      for (key in _ref1) {
        val = _ref1[key];
        if (this.schema != null) {
          (function(_this) {
            return (function(val) {
              return _this.properties[key] = extend({}, val);
            });
          })(this)(val);
        }
      }
      this.id = data != null ? data.id : void 0;
      if (this.id == null) {
        this.id = uuid.v4();
      }
      if (this.version == null) {
        this.version = 1;
      }
      this.data = data;
      this.setProperties(data);
      violations = [];
      _ref2 = this.properties;
      for (name in _ref2) {
        prop = _ref2[name];
        if (prop.value == null) {
          prop.value = (_ref3 = prop.opts) != null ? _ref3.defaultValue : void 0;
        }
        if (!prop.value) {
          if ((_ref4 = prop.opts) != null ? _ref4.required : void 0) {
            violations.push("'" + name + "' is required for " + this.constructor.name);
          }
        } else {
          check = (function() {
            switch (prop.type) {
              case 'string' || 'number' || 'boolean':
                return typeof prop.value === prop.type;
              case 'date':
                if (typeof prop.value === 'string') {
                  prop.value = new Date(prop.value);
                }
                return prop.value instanceof Date;
              case 'array':
                return prop.value instanceof Array;
              default:
                return true;
            }
          })();
          if ((prop.type != null) && !check) {
            violations.push("'" + name + "' must be a " + prop.type);
          }
          if ((prop.model != null) && prop.value instanceof Array && prop.mode !== 2) {
            violations.push("'" + name + "' cannot be an array of " + prop.model);
          }
        }
        if (prop.mode === 2) {
          if (prop.value == null) {
            prop.value = [];
          }
        }
      }
      this.log.debug("done constructing " + this.name);
      assert(violations.length === 0, violations);
    }

    DataStoreModel.prototype.serialize = function(notag) {
      var data, prop, result, x, y, _ref;
      result = {
        id: this.id
      };
      _ref = this.properties;
      for (prop in _ref) {
        data = _ref[prop];
        if (!(data.value != null)) {
          continue;
        }
        x = data.value;
        result[prop] = (function() {
          var _i, _len, _results;
          switch (false) {
            case !(x instanceof DataStoreModel):
              return x.id;
            case !(x instanceof Array):
              _results = [];
              for (_i = 0, _len = x.length; _i < _len; _i++) {
                y = x[_i];
                _results.push(y instanceof DataStoreModel ? y.id : y);
              }
              return _results;
              break;
            default:
              return x;
          }
        })();
      }
      if (notag) {
        return result;
      }
      data = {};
      data["" + this.name] = result;
      return data;
    };

    DataStoreModel.prototype.get = function() {
      var cacheComputed, cachedFor, callback, enforce, enforceCheck, opts, prop, property, value, _i, _ref, _ref1;
      property = arguments[0], opts = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
      assert(this.properties.hasOwnProperty(property), "attempting to retrieve '" + property + "' which doesn't exist in this model");
      prop = this.properties[property];
      enforceCheck = opts.length ? opts[0].enforce : true;
      enforce = function(x) {
        var id, record, results, val, validator, violations, _ref, _ref1;
        if (!enforceCheck) {
          return x;
        }
        this.log.debug("checking " + property + " with " + x);
        if (x == null) {
          x = (_ref = prop.opts) != null ? _ref.defaultValue : void 0;
        }
        violations = [];
        validator = prop != null ? (_ref1 = prop.opts) != null ? _ref1.validator : void 0 : void 0;
        val = (function() {
          var _ref2, _ref3, _ref4;
          switch (false) {
            case !(x == null):
              if ((_ref2 = prop.opts) != null ? _ref2.required : void 0) {
                violations.push("'" + property + "' is a required property");
              }
              return x;
            case !((prop.model != null) && typeof prop.model !== 'string'):
              if (!(x instanceof prop.model)) {
                violations.push("'" + property + "' must be an instance of " + ((_ref3 = prop.model.prototype) != null ? (_ref4 = _ref3.constructor) != null ? _ref4.name : void 0 : void 0));
              }
              switch (prop.mode) {
                case 1:
                  return x;
                case 2:
                  return [x];
              }
              break;
            case !((prop.model != null) && x instanceof Array && prop.mode === 2):
              results = ((function() {
                var _j, _len, _ref5, _results;
                if (!(id instanceof DataStoreModel)) {
                  _ref5 = prop.value;
                  _results = [];
                  for (_j = 0, _len = _ref5.length; _j < _len; _j++) {
                    id = _ref5[_j];
                    _results.push(this.store.findRecord(prop.model, id));
                  }
                  return _results;
                }
              }).call(this)).filter(function(e) {
                return e != null;
              });
              if (results.length) {
                return results;
              } else {
                return x;
              }
              break;
            case !((prop.model != null) && x instanceof DataStoreModel):
              switch (prop.mode) {
                case 1:
                  return x;
                case 2:
                  return [x];
              }
              break;
            case !((prop.model != null) && x instanceof Object):
              return x;
            case !((prop.model != null) && prop.mode !== 3):
              record = this.store.findRecord(prop.model, x);
              if (record == null) {
                violations.push("'" + property + "' must be a model of " + prop.model + ", unable to find using " + x);
              }
              switch (prop.mode) {
                case 1:
                  return record;
                case 2:
                  return [record];
                case 3:
                  return null;
              }
              break;
            case !(x instanceof Array && prop.opts.unique):
              return x.unique();
            default:
              return x;
          }
        }).call(this);
        assert(violations.length === 0, violations);
        if (validator != null) {
          return validator.call(this, val);
        } else {
          return val;
        }
      };
      if (typeof (prop != null ? prop.computed : void 0) === 'function' && this.store.isReady) {
        this.log.debug("issuing get on computed property: %s", property);
        value = prop.value = enforce.call(this, prop.value);
        if (value && this.useCache && prop.cachedOn && (((_ref = prop.opts) != null ? _ref.cache : void 0) !== false)) {
          cachedFor = (new Date() - prop.cachedOn) / 1000;
          if (cachedFor < this.useCache) {
            this.log.debug({
              method: 'get',
              property: property,
              id: this.id
            }, "returning cached value: " + value + " will refresh in " + (this.useCache - cachedFor) + " seconds");
            if (typeof callback === "function") {
              callback(null, value);
            }
            return value;
          } else {
            this.log.info({
              method: 'get',
              property: property,
              id: this.id
            }, "re-computing expired cached property (" + cachedFor + " secs > " + this.useCache + " secs)");
          }
        }
        this.log.debug({
          method: 'get',
          property: property,
          id: this.id
        }, "computing a new value!");
        cacheComputed = (function(_this) {
          return function(err, value) {
            if (!(err && _this.useCache)) {
              prop.value = value;
              prop.cachedOn = new Date();
            }
            return typeof callback === "function" ? callback(err, enforce.call(_this, value)) : void 0;
          };
        })(this);
        if ((_ref1 = prop.opts) != null ? _ref1.async : void 0) {
          prop.computed.apply(this, [cacheComputed, prop]);
        } else {
          value = prop.value = prop.computed.apply(this);
          if (typeof callback === "function") {
            callback(null, enforce.call(this, prop.value));
          }
        }
        return value;
      } else {
        this.log.debug("issuing get on static property: %s", property);
        if (this.store.isReady) {
          prop.value = enforce.call(this, prop != null ? prop.value : void 0);
        }
        value = prop.value;
        this.log.debug({
          method: 'get',
          property: property,
          id: this.id
        }, "issuing get on " + property + " with " + value);
        if (typeof callback === "function") {
          callback(null, value);
        }
        return value;
      }
    };

    DataStoreModel.prototype.getProperties = function(props, callback) {
      var property, self, start, tasks, value;
      if (typeof props === 'function') {
        callback = props;
        props = this.properties;
      } else {
        if ((props != null) && !(props instanceof Array)) {
          props = [props];
        }
        if (props == null) {
          props = this.properties;
        }
      }
      self = this;
      tasks = {};
      for (property in props) {
        value = props[property];
        if (typeof value.computed === 'function') {
          (function(property) {
            self.log.info("scheduling task for computed property: " + property + "...");
            return tasks[property] = function(callback) {
              return self.get(property, callback);
            };
          })(property);
        }
      }
      start = new Date();
      return async.parallel(tasks, (function(_this) {
        return function(err, results) {
          var data, duration, statics;
          results.id = _this.id;
          _this.log.trace({
            method: 'getProperties',
            id: _this.id,
            results: results
          }, 'computed properties');
          statics = {};
          for (property in props) {
            data = props[property];
            if (!data.computed) {
              statics[property] = _this.get(property);
            }
          }
          _this.log.trace({
            method: 'getProperties',
            id: _this.id,
            statics: statics
          }, 'static properties');
          results = extend(statics, results);
          for (property in results) {
            if (property.indexOf('++') > 0) {
              delete results[property];
            }
          }
          duration = new Date() - start;
          if (duration > 1000) {
            _this.log.warn({
              method: 'getProperties',
              duration: duration,
              numComputed: Object.keys(tasks).length,
              id: _this.id,
              computed: Object.keys(tasks),
              results: results
            }, "processing properties took " + duration + " ms exceeding threshold!");
          }
          _this.log.debug({
            method: 'getProperties',
            id: _this.id,
            results: results
          }, 'final results before callback');
          return callback(results);
        };
      })(this));
    };

    DataStoreModel.prototype.set = function() {
      var ArrayEquals, cval, isDirty, nval, opts, prop, property, setting, value, _base, _i, _j, _len, _ref, _ref1;
      property = arguments[0], opts = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), value = arguments[_i++];
      if ((this.schema != null) && !this.properties.hasOwnProperty(property)) {
        return;
      }
      if (typeof value === 'function') {
        if (property instanceof Array) {
          for (_j = 0, _len = property.length; _j < _len; _j++) {
            prop = property[_j];
            this.properties[prop] = {
              inherit: true
            };
          }
          property = property.join('++');
        }
        if ((_ref = this.properties[property]) != null) {
          _ref.computed = value;
        }
        return (_base = this.properties)[property] != null ? _base[property] : _base[property] = {
          computed: value
        };
      } else {
        ArrayEquals = function(a, b) {
          return a.length === b.length && a.every(function(elem, i) {
            return elem === b[i];
          });
        };
        cval = (_ref1 = this.properties[property]) != null ? _ref1.value : void 0;
        nval = value;
        isDirty = (function() {
          switch (false) {
            case !!this.properties.hasOwnProperty(property):
              return false;
            case cval !== nval:
              return false;
            case !(cval instanceof Array && nval instanceof Array):
              return !ArrayEquals(cval, nval);
            default:
              return true;
          }
        }).call(this);
        this.log.debug({
          method: 'set',
          property: property,
          id: this.id
        }, "compared " + property + " " + cval + " with " + nval + "... isDirty:" + isDirty);
        setting = {
          isDirty: isDirty,
          lvalue: cval,
          value: nval
        };
        if (this.properties.hasOwnProperty(property)) {
          return this.properties[property] = extend(this.properties[property], setting);
        } else {
          return this.properties[property] = setting;
        }
      }
    };

    DataStoreModel.prototype.setProperties = function(obj) {
      var property, value, _results;
      _results = [];
      for (property in obj) {
        value = obj[property];
        _results.push(this.set(property, value));
      }
      return _results;
    };

    DataStoreModel.prototype.update = function(data) {
      var _ref, _ref1;
      if ((_ref = this.controller) != null) {
        if (typeof _ref.beforeUpdate === "function") {
          _ref.beforeUpdate(data);
        }
      }
      this.setProperties(data);
      return (_ref1 = this.controller) != null ? typeof _ref1.afterUpdate === "function" ? _ref1.afterUpdate(data) : void 0 : void 0;
    };

    DataStoreModel.prototype.dirtyProperties = function() {
      var data, prop, _ref, _results;
      _ref = this.properties;
      _results = [];
      for (prop in _ref) {
        data = _ref[prop];
        if (data.isDirty) {
          _results.push(prop);
        }
      }
      return _results;
    };

    DataStoreModel.prototype.clearDirty = function() {
      var data, prop, _ref, _results;
      _ref = this.dirtyProperties();
      _results = [];
      for (prop in _ref) {
        data = _ref[prop];
        _results.push(data.isDirty = false);
      }
      return _results;
    };

    DataStoreModel.prototype.isDirty = function(properties) {
      var dirty;
      dirty = this.dirtyProperties();
      if (properties == null) {
        return dirty.length > 0;
      }
      if (!(properties instanceof Array)) {
        properties = [properties];
      }
      dirty = dirty.join(' ');
      return properties.some(function(prop) {
        return ~dirty.indexOf(prop);
      });
    };

    DataStoreModel.prototype.save = function(callback) {
      var err, _ref, _ref1;
      switch (false) {
        case callback == null:
          try {
            if ((_ref = this.controller) != null) {
              if (typeof _ref.beforeSave === "function") {
                _ref.beforeSave();
              }
            }
          } catch (_error) {
            err = _error;
            this.log.error({
              method: 'save',
              record: this.name,
              id: this.id,
              error: err
            }, 'failed to satisfy beforeSave controller calls');
            callback(err, null);
            throw err;
          }
          return this.getProperties((function(_this) {
            return function(props) {
              var _ref1, _ref2;
              if (props == null) {
                _this.log.error({
                  method: 'save',
                  id: _this.id
                }, 'failed to retrieve properties following save!');
                return callback('save failed to retrieve updated properties!', null);
              }
              _this.log.info({
                method: 'save',
                record: _this.name,
                id: _this.id
              }, "saving a 'new' record");
              try {
                if ((_ref1 = _this.store) != null) {
                  _ref1.commit(_this);
                }
                _this.clearDirty();
                _this.isSaved = true;
                if ((_ref2 = _this.controller) != null) {
                  if (typeof _ref2.afterSave === "function") {
                    _ref2.afterSave();
                  }
                }
                return callback(null, _this, props);
              } catch (_error) {
                err = _error;
                _this.log.error({
                  method: 'save',
                  record: _this.name,
                  id: _this.id,
                  error: err
                }, 'failed to commit record to the store!');
                callback(err, null);
                throw err;
              }
            };
          })(this));
        case !!this.isSaved:
          break;
        default:
          if ((_ref1 = this.store) != null) {
            _ref1.commit(this);
          }
          return this.clearDirty();
      }
    };

    DataStoreModel.prototype.destroy = function(callback) {
      var _ref, _ref1, _ref2;
      if ((_ref = this.controller) != null) {
        if (typeof _ref.beforeDestroy === "function") {
          _ref.beforeDestroy();
        }
      }
      this.isDestroy = true;
      if ((_ref1 = this.store) != null) {
        _ref1.commit(this);
      }
      if ((_ref2 = this.controller) != null) {
        if (typeof _ref2.afterDestroy === "function") {
          _ref2.afterDestroy();
        }
      }
      return typeof callback === "function" ? callback(null, true) : void 0;
    };

    return DataStoreModel;

  })(SR.Data);

  EventEmitter = require('events').EventEmitter;

  DataStoreController = (function(_super) {
    __extends(DataStoreController, _super);

    function DataStoreController(model, opts) {
      var _ref;
      this.model = model;
      assert(model instanceof DataStoreModel, "unable to create an instance of DS.Controller without underlying model!");
      this.store = model.store;
      this.log = opts != null ? (_ref = opts.log) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
    }

    DataStoreController.prototype.beforeUpdate = function(data) {
      return this.emit('beforeUpdate', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.afterUpdate = function(data) {
      this.emit('afterUpdate', [this.model.name, this.model.id]);
      return this.model.set('modifiedOn', new Date());
    };

    DataStoreController.prototype.beforeSave = function() {
      var createdOn;
      this.emit('beforeSave', [this.model.name, this.model.id]);
      this.log.trace({
        method: 'beforeSave'
      }, 'we should auto resolve belongsTo and hasMany here...');
      createdOn = this.model.get('createdOn');
      if (createdOn == null) {
        this.model.set('createdOn', new Date());
        this.model.set('modifiedOn', new Date());
        return this.model.set('accessedOn', new Date());
      }
    };

    DataStoreController.prototype.afterSave = function() {
      return this.emit('afterSave', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.beforeDestroy = function() {
      return this.emit('beforeDestroy', [this.model.name, this.model.id]);
    };

    DataStoreController.prototype.afterDestroy = function() {
      return this.emit('afterDestroy', [this.model.name, this.model.id]);
    };

    return DataStoreController;

  })(EventEmitter);

  DataStore = (function(_super) {
    var async, extend, uuid;

    __extends(DataStore, _super);

    async = require('async');

    uuid = require('node-uuid');

    extend = require('util')._extend;

    DataStore.prototype.name = null;

    DataStore.prototype.adapters = {};

    DataStore.prototype.adapter = function(type, module) {
      if ((type != null) && (module != null)) {
        return this.adapters[type] = module;
      }
    };

    DataStore.prototype.using = function(adapter) {
      return this.adapters[adapter];
    };

    DataStore.prototype.stores = {};

    DataStore.prototype.link = function(store) {
      if (store != null) {
        return this.stores[store.name] = store;
      }
    };

    function DataStore(opts) {
      var _ref, _ref1;
      if (this.name == null) {
        this.name = opts != null ? opts.name : void 0;
      }
      assert(this.name != null, "cannot construct DataStore without naming this store!");
      this.log = opts != null ? (_ref = opts.auditor) != null ? _ref.child({
        "class": this.constructor.name
      }) : void 0 : void 0;
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.authorizer = opts != null ? opts.authorizer : void 0;
      if ((_ref1 = this.authorizer) != null) {
        _ref1.link(this);
      }
      this.collections = {};
      this.entities = {};
      if ((opts != null ? opts.entities : void 0) != null) {
        this.entities = extend(this.entities, opts.entities);
      }
      this.isReady = false;
    }

    DataStore.prototype.initialize = function() {
      var collection, entity, _fn, _ref;
      if (this.isReady) {
        return;
      }
      console.log("initializing a new DataStore: " + this.name);
      this.log.info({
        method: 'initialize'
      }, 'initializing a new DataStore: %s', this.name);
      _ref = this.collections;
      _fn = (function(_this) {
        return function(collection, entity) {
          entity.registry = new DataStoreRegistry(collection, {
            log: _this.log,
            store: _this,
            persist: entity.persist
          });
          if (entity["static"] != null) {
            return entity.registry.once('ready', function() {
              var entry, _i, _len, _ref1;
              _this.log.info({
                collection: collection
              }, 'loading static records for %s', collection);
              _ref1 = entity["static"];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                entry = _ref1[_i];
                entry.saved = true;
                entity.registry.add(entry.id, entry);
              }
              return _this.log.info({
                collection: collection
              }, "autoloaded " + entity["static"].length + " static records");
            });
          }
        };
      })(this);
      for (collection in _ref) {
        entity = _ref[collection];
        _fn(collection, entity);
      }
      this.log.info({
        method: 'initialize'
      }, 'initialization complete for: %s', this.name);
      console.log("initialization complete for: " + this.name);
      this.isReady = true;
      return process.nextTick((function(_this) {
        return function() {
          return _this.emit('ready');
        };
      })(this));
    };

    DataStore.prototype.contains = function(collection, entity) {
      if (entity == null) {
        return this.collections[collection];
      }
      entity.collection = collection;
      entity.name = entity.model.prototype.name;
      if (entity.persist == null) {
        entity.persist = true;
      }
      if (entity.cache == null) {
        entity.cache = 1;
      }
      if (entity.controller == null) {
        entity.controller = DataStoreController;
      }
      this.collections[collection] = this.entities[entity.name] = entity;
      return this.log.info({
        collection: collection
      }, "registered a collection of '" + collection + "' into the store");
    };

    DataStore.prototype.open = function(requestor) {
      return this;
    };

    DataStore.prototype.notifyOn = function(collection, event, callback) {
      var entity;
      entity = this.contains(collection);
      assert((entity != null) && (entity.registry != null) && (event === 'added' || event === 'updated' || event === 'removed') && (callback != null), "must specify valid collection with event and callback to be notified");
      return entity.registry.once('ready', function() {
        return this.on(event, callback);
      });
    };

    DataStore.prototype.createRecord = function(type, data) {
      var entity, err, record;
      this.log.debug({
        method: "createRecord",
        type: type,
        data: data
      });
      try {
        entity = this.entities[type];
        record = new entity.model(data, {
          store: this,
          log: this.log,
          useCache: entity.cache
        });
        record.controller = new entity.controller(record, {
          data: data,
          log: this.log
        });
        this.log.info({
          method: "createRecord",
          id: record.id
        }, 'created a new record for %s', record.constructor.name);
      } catch (_error) {
        err = _error;
        this.log.error({
          error: err
        }, "unable to instantiate a new DS.Model for " + type);
        throw err;
      }
      return record;
    };

    DataStore.prototype.deleteRecord = function(type, id, callback) {
      var match;
      match = this.findRecord(type, id);
      if (match == null) {
        callback(null);
      }
      return match.destroy(callback);
    };

    DataStore.prototype.updateRecord = function(type, id, data, callback) {
      var record;
      record = this.findRecord(type, id);
      if (record == null) {
        callback(null);
      }
      record.update(data);
      return record.save(callback);
    };

    DataStore.prototype.findRecord = function(type, id) {
      var record, _ref, _ref1;
      if (!((type != null) && (id != null))) {
        return;
      }
      record = (_ref = this.entities[type]) != null ? (_ref1 = _ref.registry) != null ? _ref1.get(id) : void 0 : void 0;
      return record;
    };

    DataStore.prototype.findBy = function(type, condition, callback) {
      var key, records, results, value, _ref, _ref1, _ref2;
      if (!((type != null) && typeof condition === 'object')) {
        return callback("invalid findBy query params!");
      }
      this.log.debug({
        method: 'findBy',
        type: type,
        condition: condition
      }, 'issuing findBy on requested entity');
      _ref = ((function() {
        var _results;
        _results = [];
        for (key in condition) {
          value = condition[key];
          _results.push([key, value]);
        }
        return _results;
      })())[0], key = _ref[0], value = _ref[1];
      records = ((_ref1 = this.entities[type]) != null ? (_ref2 = _ref1.registry) != null ? _ref2.list() : void 0 : void 0) || [];
      results = records.filter((function(_this) {
        return function(record) {
          var err, x;
          try {
            x = record.get(key);
            return x === value || (x instanceof DataStoreModel && x.id === value);
          } catch (_error) {
            err = _error;
            _this.log.warn({
              method: 'findBy',
              type: type,
              id: record.id,
              error: err
            }, 'skipping bad record...');
            return false;
          }
        };
      })(this));
      if (!((results != null ? results.length : void 0) > 0)) {
        this.log.warn({
          method: 'findBy',
          type: type,
          condition: condition
        }, 'unable to find any records for the condition!');
      } else {
        this.log.debug({
          method: 'findBy',
          type: type,
          condition: condition
        }, 'found %d matching results', results.length);
      }
      if (typeof callback === "function") {
        callback(null, results);
      }
      return results;
    };

    DataStore.prototype.find = function(type, query, callback) {
      var id, self, tasks, _entity, _fn, _i, _len, _ref;
      _entity = this.entities[type];
      if (_entity == null) {
        return callback("DS: unable to find using unsupported type: " + type);
      }
      if (query == null) {
        query = (_ref = _entity.registry) != null ? _ref.keys() : void 0;
      }
      if (!(query instanceof Array)) {
        query = [query];
      }
      self = this;
      tasks = {};
      _fn = function(id) {
        return tasks[id] = function(callback) {
          var err, match;
          match = self.findRecord(type, id);
          if (!((match != null) && match instanceof DataStoreModel)) {
            return callback(null);
          }
          try {
            return match.getProperties(function(properties) {
              return callback(null, match);
            });
          } catch (_error) {
            err = _error;
            self.log.warn({
              error: err,
              type: type,
              id: id
            }, 'unable to obtain validated properties from the matching record');
            return callback(null);
          }
        };
      };
      for (_i = 0, _len = query.length; _i < _len; _i++) {
        id = query[_i];
        _fn(id);
      }
      this.log.info({
        method: 'find',
        type: type,
        query: query
      }, 'issuing find on requested entity');
      return async.parallel(tasks, (function(_this) {
        return function(err, results) {
          var entry, key, matches;
          if (err != null) {
            _this.log.error(err, "error was encountered while performing find operation on " + type + " with " + query + "!");
            return callback(err);
          }
          matches = (function() {
            var _results;
            _results = [];
            for (key in results) {
              entry = results[key];
              if (entry != null) {
                _results.push(entry);
              }
            }
            return _results;
          })();
          if (!((matches != null ? matches.length : void 0) > 0)) {
            _this.log.warn({
              method: 'find',
              type: type,
              query: query
            }, 'unable to find any records matching the query!');
          } else {
            _this.log.debug({
              method: 'find',
              type: type,
              query: query
            }, 'found %d matching results', matches.length);
          }
          return callback(null, matches);
        };
      })(this));
    };

    DataStore.prototype.commit = function(record) {
      var action, exists, registry, _ref;
      if (!(record instanceof DataStoreModel)) {
        return;
      }
      this.log.debug({
        method: "commit",
        record: record
      });
      registry = (_ref = this.entities[record.name]) != null ? _ref.registry : void 0;
      assert(registry != null, "cannot commit '" + record.name + "' into store which doesn't contain the collection");
      action = (function() {
        switch (false) {
          case !record.isDestroy:
            registry.remove(record.id);
            return 'removed';
          case !!record.isSaved:
            exists = (record.id != null) && (registry.get(record.id) != null);
            assert(!exists, "cannot commit a new record '" + record.name + "' into the store using pre-existing ID: " + record.id);
            if (record.id == null) {
              record.id = uuid.v4();
            }
            registry.add(record.id, record);
            return 'added';
          case !record.isDirty():
            record.changed = true;
            registry.update(record.id, record);
            delete record.changed;
            return 'updated';
        }
      })();
      this.emit('commit', [action, record.name, record.id]);
      return this.log.info({
        method: "commit",
        id: record.id
      }, "" + action + " '%s' on the store registry", record.constructor.name);
    };

    DataStore.prototype.dump = function() {
      var entity, name, record, records, _ref, _ref1, _results;
      _ref = this.entities;
      _results = [];
      for (name in _ref) {
        entity = _ref[name];
        records = (_ref1 = entity.registry) != null ? _ref1.list() : void 0;
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = records.length; _i < _len; _i++) {
            record = records[_i];
            _results1.push(this.log.info({
              model: name,
              record: record.serialize(),
              method: 'dump'
            }, "DUMP"));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return DataStore;

  })(EventEmitter);

  module.exports = DataStore;

  module.exports.Model = DataStoreModel;

  module.exports.Controller = DataStoreController;

  module.exports.Registry = DataStoreRegistry;

  module.exports.attr = function(type, opts) {
    return {
      type: type,
      opts: opts
    };
  };

  module.exports.belongsTo = function(model, opts) {
    return {
      mode: 1,
      model: model,
      opts: opts
    };
  };

  module.exports.hasMany = function(model, opts) {
    return {
      mode: 2,
      model: model,
      opts: opts
    };
  };

  module.exports.computed = function(func, opts) {
    return {
      computed: func,
      opts: opts
    };
  };

  module.exports.computedHistory = function(model, opts) {
    return {
      mode: 3,
      model: model,
      opts: opts
    };
  };

}).call(this);
