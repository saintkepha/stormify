// Generated by CoffeeScript 1.8.0
(function() {
  var Yang, YangGenerator, YangParser, spec;

  Yang = require('./yang');

  spec = require('./yang-generator-map');

  YangParser = require('yang-parser');

  YangGenerator = Yang.define('module yang-generator', {
    prefix: "yg",
    organization: "ClearPath Networks NFV R&D Group",
    contact: 'Web:  <http://www.clearpathnet.com>\nCode: <http://github.com/stormstack/stormify>\n\nAuthor: Peter K. Lee <mailto:plee@clearpathnet.com>',
    description: "\nThis module contains RPC extensions for enabling stormify\nenabled data storm endpoints to auto-generate new YANG schema\nbased models into JavaScript class hierarchy and to dynamically\nderive REST-APIs to be served via 'stormify.express' mechanism.\n\nUsing this generator, a YANG module schema definition file can\nbe pushed to a stormify endpoint and that endpoint will auto\nconstruct the YANG module instance and be ready to accept REST\nAPI calls for manipulating the record properties and instances.\n\nThis generator is a built-in module to stormify's data-storm\nmodule and usually the starting point before populating a\nstormify endpoint with data model records.\n",
    '2015-02-11': Yang.define('revision', {
      description: "Initial revision.",
      reference: "Proprietary"
    }),
    generator: Yang.define('container', {
      description: "Conceptual container representing the generator",
      modules: Yang.define('container', {
        description: "Conceptual container showing all modules generated by this generator"
      })
    }),
    'push-schema': Yang.define('rpc', {
      description: "\nPrimary routine for issuing a request to push a YANG module\nschema to the stormify enabled endpoint.\n\nResponds with JSON converted representation of YANG module\nschema upon success\n",
      using: function() {
        return 'importSchema';
      }
    }),

    /*
     * END OF YANG SCHEMA
     *
     * below contains custom routines for supporting the RPC operation
     */
    importSchema: function(schema) {
      var err, module;
      try {
        module = this.generate(schema);
        this._models.register(module);
        return module.toJSON();
      } catch (_error) {
        err = _error;
        throw err;
      }
    },
    generate: function(schema, parser, map) {
      var statement;
      this.parser = parser != null ? parser : YangParser;
      this.map = map != null ? map : spec;
      this.assert((schema != null) && typeof schema === 'string', "must pass in input schema text to process for YANG");
      statement = this.parser.parse(schema);
      this.assert((statement != null) && statement.kw === 'module', "must pass in YANG module schema definition");
      if (this.groupings == null) {
        this.groupings = {};
      }
      return this.processStatement(statement);
    },
    resolve: function(grouping, props) {
      if (!this.groupings.hasOwnProperty(grouping)) {
        console.log("WARNING: trying to 'uses' using " + grouping + " identifier not found");
        return null;
      }
      return this.groupings[grouping];
    },
    processStatement: function(statement, map) {
      var hasMany, importModule, includeModule, keyword, param, properties, resolveMap, results, subs, value;
      if (map == null) {
        map = this.map;
      }
      keyword = statement.kw, param = statement.arg, subs = statement.substmts;
      resolveMap = (function(_this) {
        return function(map, key) {
          var v, value, _ref;
          value = (_ref = map[key]) != null ? _ref : _this.map[key];
          switch (false) {
            case !(value instanceof Function):
              return value();
            case !(value instanceof Array):
              v = value[0];
              v = (function() {
                switch (false) {
                  case !(v instanceof Function):
                    return v();
                  default:
                    return v;
                }
              })();
              return {
                type: 'array',
                value: v
              };
            default:
              return value;
          }
        };
      })(this);
      map = resolveMap(map, keyword);
      if ((map != null ? map.type : void 0) === 'array') {
        hasMany = true;
        map = map.value;
      }
      if (map == null) {
        console.log("WARNING: unsupported YANG " + keyword + " found, ignoring...");
        return;
      }
      results = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = subs.length; _i < _len; _i++) {
          statement = subs[_i];
          _results.push(this.processStatement(statement, map));
        }
        return _results;
      }).call(this)).filter(function(e) {
        return (e != null) && (e.value != null);
      });
      if (!(results.length > 0)) {
        return {
          name: keyword,
          value: param
        };
      }
      properties = results.reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      if (keyword === 'module' || keyword === 'submodule') {
        return Yang.define("" + keyword + " " + param, properties);
      }
      importModule = function(module, opts) {
        return null;
      };
      includeModule = function(module, opts) {
        return null;
      };
      value = (function() {
        switch (keyword) {
          case 'import':
            return importModule(param, properties);
          case 'include':
            return includeModule(param, properties);
          case 'uses':
            return this.resolve(param, properties);
          case 'extension':
          case 'grouping':
            return Yang.define("" + keyword + " " + param, properties);
          default:
            return Yang.define(keyword, properties);
        }
      }).call(this);
      switch (keyword) {
        case 'grouping':
          this.grouping[param] = value;
          break;
        case 'extension':
          void 0;
          break;
        case 'typedef':
          void 0;
          break;
        case 'list':
          value.set({
            type: Yang.define('container', properties)
          });
          break;
        case 'leaf':
        case 'leaf-list':
          value.set({
            type: properties.type
          });
      }
      return {
        name: param,
        value: value
      };
    }
  });

  module.exports = YangGenerator;

}).call(this);
