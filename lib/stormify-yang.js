// Generated by CoffeeScript 1.8.0
(function() {
  var Yang, YangParser, YangSpec, YangStorm, toSource;

  Yang = require('./yang/yang-class');

  YangSpec = require('./yang/yang-generator-map');

  YangParser = require('yang-parser');

  toSource = require('tosource');

  YangStorm = Yang.define('module stormify-yang', {
    prefix: "yg",
    organization: "ClearPath Networks NFV R&D Group",
    contact: 'Web:  <http://www.clearpathnet.com>\nCode: <http://github.com/stormstack/stormify>\n\nAuthor: Peter K. Lee <mailto:plee@clearpathnet.com>',
    description: "\nThis module contains RPC extensions for enabling stormify\nenabled data storm endpoints to auto-generate new YANG schema\nbased models into JavaScript class hierarchy and to dynamically\nderive REST-APIs to be served via 'stormify.express' mechanism.\n\nUsing this generator, a YANG module schema definition file can\nbe pushed to a stormify endpoint and that endpoint will auto\nconstruct the YANG module instance and be ready to accept REST\nAPI calls for manipulating the record properties and instances.\n\nThis generator is a built-in capability to stormify framework\nand usually the starting point before populating a target\nendpoint with data model records and associated RPC functions.\n",
    '2015-02-11': Yang.define('revision', {
      description: "Initial revision.",
      reference: "Proprietary"
    }),
    generator: Yang.define('container', {
      description: "Conceptual container representing the generator",
      modules: Yang.define('container', {
        description: "Conceptual container showing all modules generated by this generator"
      })
    }),
    'push-schema': Yang.define('rpc importSchema', {
      description: "\nPrimary routine for executing a request to push a YANG module\nschema to the target endpoint.\n\nResponds with JSON converted representation of YANG module\nschema upon success.\n"
    }),
    'pull-schema': Yang.define('rpc extractSchema', {
      description: "\nPrimary routine for executing a request to pull YANG module\nschema from the target endpoint.\n\nResponds with YANG or JSON representation of matching YANG\nmodule's schema upon success depending on the specified HTTP\nheader.\n"
    }),
    'push-js': Yang.define('rpc importJavascript', {
      description: "\nSecondary routine for executing a request to push JS code\nfunctions representing RPC functionality to a previously\nimported YANG schema.\n\nThis operation should only take place between trusted systems\nsince it is possible arbitrary function can be executed,\nincluding crashing the receiving system.\n\nNo attempt will be made to qualify the code being pushed.\n\nThe input format MUST be JSON-formatted containing JS\nrepresented in string format as follows:\n\n{\n  module: 'some-name',\n  rpc: {\n    somefunc: 'function (hello) { return hello; }',\n    otherfunc: 'function (bye) { return bye; }'\n  }\n}\n\nThe function(s) will be merged into the target module if found\nto have been auto-generated via a prior 'push-schema' rpc call.\n\nThe function(s) will have access to all the pre-existing\nfunctions within the module's instance space.  For details, be\nsure to review/understand the stormify data-storm class\nhierarchy for traversing/accessing properties within the given\nmodule.\n"
    }),
    'pull-js': Yang.define('rpc extractJavascript', {
      description: "\nSecondary routine for executing a request to pull JS code\nfunctions representing RPC functionality from a previously\nimported YANG schema.\n"
    }),

    /*
     * END OF YANG SCHEMA
     *
     * below contains custom routines for supporting the RPC operation
     */
    modules: this._models,
    importSchema: function(payload, encoding) {
      var err, module;
      if (encoding == null) {
        encoding = 'yang';
      }
      try {
        module = this.generate(payload);
        this.modules.register(module);
        return module.toJSON();
      } catch (_error) {
        err = _error;
        throw err;
      }
    },
    extractSchema: function(payload, encoding) {
      var err, module;
      if (encoding == null) {
        encoding = 'yang';
      }
      try {
        module = (this.modules.contains(payload.module)).model;
        switch (encoding) {
          case 'yang':
            return module.toYANG();
          case 'json':
            return module.toJSON();
        }
      } catch (_error) {
        err = _error;
        throw err;
      }
    },
    importJavascript: function(payload) {
      var err, k, module, v, _ref;
      try {
        module = (this.modules.contains(payload.module)).model;
        _ref = payload.rpc;
        for (k in _ref) {
          v = _ref[k];
          payload.rpc[k] = eval("(" + v + ")");
        }
        return module.include(payload.rpc);
      } catch (_error) {
        err = _error;
        throw err;
      }
    },
    extractJavascript: function(payload) {
      var err, k, module, v, _ref;
      try {
        module = (this.modules.contains(payload.module)).model;
        payload.rpc = {};
        _ref = module.prototype;
        for (k in _ref) {
          v = _ref[k];
          if (k !== 'constructor' && !(typeof v.get === "function" ? v.get('storm') : void 0)) {
            payload.rpc[k] = toSource(v);
          }
        }
        return payload;
      } catch (_error) {
        err = _error;
        throw err;
      }
    },
    generate: function(schema, parser, map) {
      var statement;
      this.parser = parser != null ? parser : YangParser;
      this.map = map != null ? map : YangSpec;
      this.assert((schema != null) && typeof schema === 'string', "must pass in input schema text to process for YANG");
      statement = this.parser.parse(schema);
      this.assert((statement != null) && statement.kw === 'module', "must pass in YANG module schema definition");
      if (this.groupings == null) {
        this.groupings = {};
      }
      return this.processStatement(statement);
    },
    resolve: function(grouping, props) {
      if (!this.groupings.hasOwnProperty(grouping)) {
        console.log("WARNING: trying to 'uses' using " + grouping + " identifier not found");
        return null;
      }
      return this.groupings[grouping];
    },
    processStatement: function(statement, map) {
      var hasMany, importModule, includeModule, keyword, param, properties, resolveMap, results, subs, value;
      if (map == null) {
        map = this.map;
      }
      keyword = statement.kw, param = statement.arg, subs = statement.substmts;
      resolveMap = (function(_this) {
        return function(map, key) {
          var v, value, _ref;
          value = (_ref = map[key]) != null ? _ref : _this.map[key];
          switch (false) {
            case !(value instanceof Function):
              return value();
            case !(value instanceof Array):
              v = value[0];
              v = (function() {
                switch (false) {
                  case !(v instanceof Function):
                    return v();
                  default:
                    return v;
                }
              })();
              return {
                type: 'array',
                value: v
              };
            default:
              return value;
          }
        };
      })(this);
      map = resolveMap(map, keyword);
      if ((map != null ? map.type : void 0) === 'array') {
        hasMany = true;
        map = map.value;
      }
      if (map == null) {
        console.log("WARNING: unsupported YANG " + keyword + " found, ignoring...");
        return;
      }
      results = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = subs.length; _i < _len; _i++) {
          statement = subs[_i];
          _results.push(this.processStatement(statement, map));
        }
        return _results;
      }).call(this)).filter(function(e) {
        return (e != null) && (e.value != null);
      });
      if (!(results.length > 0)) {
        return {
          name: keyword,
          value: param
        };
      }
      properties = results.reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      if (keyword === 'module' || keyword === 'submodule') {
        return Yang.define("" + keyword + " " + param, properties);
      }
      importModule = function(module, opts) {
        return null;
      };
      includeModule = function(module, opts) {
        return null;
      };
      value = (function() {
        switch (keyword) {
          case 'import':
            return importModule(param, properties);
          case 'include':
            return includeModule(param, properties);
          case 'uses':
            return this.resolve(param, properties);
          case 'extension':
          case 'grouping':
          case 'rpc':
            return Yang.define("" + keyword + " " + param, properties);
          default:
            return Yang.define(keyword, properties);
        }
      }).call(this);
      switch (keyword) {
        case 'grouping':
          this.grouping[param] = value;
          break;
        case 'extension':
          void 0;
          break;
        case 'typedef':
          void 0;
          break;
        case 'list':
          value.set({
            type: Yang.define('container', properties)
          });
          break;
        case 'leaf':
        case 'leaf-list':
          value.set({
            type: properties.type
          });
      }
      return {
        name: param,
        value: value
      };
    }
  });

  module.exports = YangStorm;

}).call(this);
