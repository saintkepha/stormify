// Generated by CoffeeScript 1.9.1
(function() {
  var AnonymousStrategy, BearerStrategy, DataStore, assert, authorizer, createStore, getter, passport, poster, putter, remover, serializer;

  assert = require('assert');

  Array.prototype.unique = function() {
    var i, key, output, ref, results, val, value;
    if (!(this.length > 0)) {
      return this;
    }
    output = {};
    for (key = i = 0, ref = this.length - 1; 0 <= ref ? i <= ref : i >= ref; key = 0 <= ref ? ++i : --i) {
      val = this[key];
      switch (false) {
        case !(typeof val === 'object' && (val.id != null)):
          output[val.id] = val;
          break;
        default:
          output[val] = val;
      }
    }
    results = [];
    for (key in output) {
      value = output[key];
      results.push(value);
    }
    return results;
  };

  Array.prototype.contains = function(query) {
    var hit;
    if (typeof query !== "object") {
      return false;
    }
    hit = Object.keys(query).length;
    return this.some(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (item[key] === val) {
          match += 1;
        }
      }
      if (match === hit) {
        return true;
      } else {
        return false;
      }
    });
  };

  Array.prototype.where = function(query) {
    var hit;
    if (typeof query !== "object") {
      return [];
    }
    hit = Object.keys(query).length;
    return this.filter(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (item[key] === val) {
          match += 1;
        }
      }
      if (match === hit) {
        return true;
      } else {
        return false;
      }
    });
  };

  Array.prototype.without = function(query) {
    if (typeof query !== "object") {
      return this;
    }
    return this.filter(function(item) {
      var key, val;
      for (key in query) {
        val = query[key];
        if (item[key] !== val) {
          return true;
        }
      }
      return false;
    });
  };

  Array.prototype.pushRecord = function(record) {
    if (typeof record !== "object") {
      return null;
    }
    if (!this.contains({
      id: record.id
    })) {
      return this.push(record);
    }
  };

  DataStore = require('./data-store');

  createStore = function(opts) {
    var ref, ref1, ref2, store;
    assert((ref = opts.store) != null ? (ref1 = ref.prototype) != null ? (ref2 = ref1.constructor) != null ? ref2.name : void 0 : void 0 : void 0, "store must be a class definition for the DataStore");
    store = new opts.store({
      auditor: opts.auditor,
      authorizer: opts.authorizer,
      datadir: opts.datadir
    });
    assert(store instanceof DataStore, "unable to instantiate store as DataStore instance");
    return store;
  };

  passport = require('passport');

  BearerStrategy = require('passport-http-bearer');

  AnonymousStrategy = require('passport-anonymous');

  passport.use(new AnonymousStrategy);

  authorizer = function(store) {
    if ((store.authorizer != null) && store.authorizer instanceof DataStore) {
      passport.use(new BearerStrategy(function(token, done) {
        var identity, session;
        token = store.authorizer.findRecord('token', token);
        if ((token != null) && token instanceof DataStore.Model) {
          identity = token.get('identity');
          session = token.get('session');
          if ((identity != null) && (session != null)) {
            return done(null, session, {
              scope: identity.get('scope')
            });
          }
        }
        return done(null, false);
      }));
      return passport.authenticate('bearer', {
        session: false
      });
    } else {
      return passport.authenticate('anonymous', {
        session: false
      });
    }
  };

  serializer = function(data) {
    var entry, i, len, results;
    switch (false) {
      case !(data instanceof Array):
        results = [];
        for (i = 0, len = data.length; i < len; i++) {
          entry = data[i];
          results.push(serializer(entry));
        }
        return results;
      case !(data instanceof DataStore.Model):
        return data.serialize();
      default:
        return data;
    }
  };

  poster = function(store, type) {
    return function(req, res, next) {
      var err, record, ref;
      assert(store instanceof DataStore && (type != null) && store.entities.hasOwnProperty(type), "invalid stormify.poster initialization");
      try {
        assert((req.body != null) && req.body.hasOwnProperty(type), "attempting to POST without proper '" + type + "' as root element!");
      } catch (_error) {
        err = _error;
        return res.status(500).send({
          error: err
        });
      }
      if ((ref = store.log) != null) {
        ref.info({
          stormify: "poster",
          request: req.body
        }, "stormify.poster for '" + type + "'");
      }
      try {
        record = store.open(req.user).createRecord(type, req.body[type]);
        return record.save((function(_this) {
          return function(err, props) {
            var ref1;
            if (err == null) {
              res.locals.result = record.serialize({
                tag: true
              });
              if ((ref1 = store.log) != null) {
                ref1.info({
                  query: req.params.id,
                  result: res.locals.result
                }, 'poster results for %s', type);
              }
              res.setHeader('Expires', '-1');
              return next();
            } else {
              return res.status(500).send({
                error: {
                  message: "Unable to create a new record for " + type + " during save",
                  origin: err
                }
              });
            }
          };
        })(this));
      } catch (_error) {
        err = _error;
        if (!res.headersSent) {
          res.status(500).send({
            error: {
              message: "Unable to create a new record for " + type,
              origin: err
            }
          });
          throw err;
        }
      }
    };
  };

  getter = function(store, type) {
    return function(req, res, next) {
      var collection, condition, err, ref;
      assert(store instanceof DataStore && (type != null) && store.entities.hasOwnProperty(type), "invalid stormify.getter initialization");
      condition = req.query.ids;
      if (condition == null) {
        condition = req.params.id;
      }
      if (Object.keys(req.query).length !== 0) {
        if (condition == null) {
          condition = req.query;
        }
      }
      collection = store.entities[type].collection;
      if ((ref = store.log) != null) {
        ref.info({
          stormify: "getter",
          query: condition
        }, "stormify.getter for '" + type + "'");
      }
      try {
        return store.open(req.user).find(type, condition, (function(_this) {
          return function(err, matches) {
            var o, ref1, ref2;
            if (err != null) {
              throw err;
            }
            if ((req.params.id != null) && matches.length !== 1) {
              return res.status(404).send();
            }
            res.locals.matches = matches;
            o = {};
            res.locals.result = (function() {
              switch (false) {
                case !((condition instanceof Array) || (condition instanceof Object) || (condition == null)):
                  o[collection] = serializer(matches);
                  return o;
                default:
                  o[type] = serializer(matches[0]);
                  return o;
              }
            })();
            if ((ref1 = store.log) != null) {
              ref1.info({
                query: condition,
                matches: matches.length
              }, "getter for '%s' was successful", type);
            }
            if ((ref2 = store.log) != null) {
              ref2.debug({
                query: condition,
                result: res.locals.result
              }, 'getter results for %s', type);
            }
            res.setHeader('Expires', '-1');
            return next();
          };
        })(this));
      } catch (_error) {
        err = _error;
        return res.status(500).send({
          error: {
            message: "Unable to perform find operation for " + type,
            origin: err
          }
        });
      }
    };
  };

  putter = function(store, type) {
    return function(req, res, next) {
      var err, ref;
      assert(store instanceof DataStore && (type != null) && store.entities.hasOwnProperty(type), "invalid stormify.poster initialization");
      try {
        assert((req.body != null) && req.body.hasOwnProperty(type), "attempting to PUT without proper '" + type + "' as root element!");
      } catch (_error) {
        err = _error;
        return res.status(500).send({
          error: err
        });
      }
      if ((ref = store.log) != null) {
        ref.info({
          stormify: "putter",
          request: req.body
        }, "stormify.putter for '" + type + "'");
      }
      try {
        return store.open(req.user).updateRecord(type, req.params.id, req.body[type], (function(_this) {
          return function(err, result) {
            var ref1;
            if (err != null) {
              throw err;
            }
            if ((result != null) && result instanceof DataStore.Model) {
              res.locals.result = result.serialize({
                tag: true
              });
              if ((ref1 = store.log) != null) {
                ref1.info({
                  query: req.params.id,
                  result: res.locals.result
                }, 'putter results for %s', type);
              }
              res.setHeader('Expires', '-1');
              return next();
            } else {
              return res.status(404).send();
            }
          };
        })(this));
      } catch (_error) {
        err = _error;
        return res.status(500).send({
          error: {
            message: "Unable to perform update operation for " + type,
            origin: err
          }
        });
      }
    };
  };

  remover = function(store, type) {
    return function(req, res, next) {
      var err, ref;
      assert(store instanceof DataStore && (type != null) && store.entities.hasOwnProperty(type), "invalid stormify.remover initialization");
      if ((ref = store.log) != null) {
        ref.info({
          stormify: "remover"
        }, "stormify.remover for '" + type + "'");
      }
      try {
        return store.open(req.user).deleteRecord(type, req.params.id, (function(_this) {
          return function(err, result) {
            var ref1;
            if (!((err != null) && result === false)) {
              res.locals.result = result;
              if ((ref1 = store.log) != null) {
                ref1.debug({
                  query: req.params.id,
                  result: res.locals.result
                }, 'remover results for %s', type);
              }
              return next();
            } else {
              return res.status(400).send();
            }
          };
        })(this));
      } catch (_error) {
        err = _error;
        return res.status(500).send({
          error: {
            message: "Unable to perform delete operation for " + type,
            origin: err
          }
        });
      }
    };
  };

  module.exports = {
    createStore: createStore,
    SR: require('./stormregistry'),
    DS: DataStore,
    authorizer: authorizer,
    poster: poster,
    getter: getter,
    putter: putter,
    remover: remover
  };

  module.exports.serve = function(store, opts) {
    var action, baseUrl, collection, entity, fn, name, ref, ref1, ref2, ref3, ref4, ref5, results;
    if (this.del == null) {
      this.del = this["delete"];
    }
    assert((this.post != null) && (this.get != null) && (this.put != null) && (this.del != null), "cannot stormify.serve without CRUD operators present in the running context!");
    assert(store instanceof DataStore, "cannot stormify.serve without valid instance of DataStore!");
    if ((ref = store.log) != null) {
      ref.info({
        method: "serve"
      }, "STORMIFYING data entities!");
    }
    baseUrl = (opts != null ? opts.baseUrl : void 0) || '';
    ref1 = store.collections;
    results = [];
    for (collection in ref1) {
      entity = ref1[collection];
      if ((ref2 = store.log) != null) {
        ref2.debug({
          method: "serve"
        }, "processing " + collection + "...");
      }
      if (entity.hidden) {
        continue;
      }
      if (entity.serve != null) {
        entity.serve.call(this, opts);
        if ((ref3 = store.log) != null) {
          ref3.info({
            method: "serve"
          }, "serving custom REST endpoint(s) for: " + collection);
        }
        if (entity.serveOverride) {
          continue;
        }
      }
      name = entity.name;
      this.get(baseUrl + "/" + collection, authorizer(store), getter(store, name), function() {
        return this.send(this.res.locals.result);
      });
      this.get(baseUrl + "/" + collection + "/:id", authorizer(store), getter(store, name), function() {
        return this.send(this.res.locals.result);
      });
      if (!(entity.isReadOnly || entity.persist === false)) {
        this.post(baseUrl + "/" + collection, authorizer(store), poster(store, name), function() {
          return this.send(this.res.locals.result);
        });
        this.put(baseUrl + "/" + collection + "/:id", authorizer(store), putter(store, name), function() {
          return this.send(this.res.locals.result);
        });
        this.del(baseUrl + "/" + collection + "/:id", authorizer(store), remover(store, name), function() {
          return this.res.status(204).send();
        });
        fn = (function(_this) {
          return function(action) {
            var ref5;
            if ((ref5 = store.log) != null) {
              ref5.info({
                method: "serve"
              }, "exposing actions: " + baseUrl + "/" + collection + "/:id/" + action);
            }
            return _this.post(baseUrl + "/" + collection + "/:id/" + action, authorizer(store), getter(store, name), function() {
              var record;
              record = this.res.locals.matches[0];
              return record.invoke(action, this.req.query, this.req.body).then((function(_this) {
                return function(response) {
                  return _this.send(response);
                };
              })(this), (function(_this) {
                return function(error) {
                  return _this.res.status(500).send({
                    error: error
                  });
                };
              })(this));
            });
          };
        })(this);
        for (action in (ref4 = entity.controller) != null ? ref4.prototype.actions : void 0) {
          fn(action);
        }
      }
      results.push((ref5 = store.log) != null ? ref5.info({
        method: "serve"
      }, "auto-generated REST endpoints at: " + baseUrl + "/" + collection) : void 0);
    }
    return results;
  };

}).call(this);
