// Generated by CoffeeScript 1.8.0
(function() {
  var AnonymousStrategy, BearerStrategy, DataStore, assert, authorizer, getter, passport, poster, putter, remover, serializer,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  assert = require('assert');

  Array.prototype.unique = function() {
    var key, output, value, _i, _ref, _results;
    output = {};
    for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
      output[this[key]] = this[key];
    }
    _results = [];
    for (key in output) {
      value = output[key];
      _results.push(value);
    }
    return _results;
  };

  Array.prototype.where = function(query) {
    var hit;
    if (typeof query !== "object") {
      return [];
    }
    hit = Object.keys(query).length;
    return this.filter(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (item[key] === val) {
          match += 1;
        }
      }
      if (match === hit) {
        return true;
      } else {
        return false;
      }
    });
  };

  DataStore = require('./data-store');

  passport = require('passport');

  BearerStrategy = require('passport-http-bearer');

  AnonymousStrategy = require('passport-anonymous');

  passport.use(new AnonymousStrategy);

  authorizer = function(store) {
    if ((store.authorizer != null) && store.authorizer instanceof DataStore) {
      passport.use(new BearerStrategy(function(token, done) {
        var identity;
        token = store.authorizer.findRecord('token', token);
        if (token instanceof DataStore.Model) {
          identity = token.get('identity');
        }
        if (!((identity != null) && identity instanceof DataStore.Model)) {
          return done(null, false);
        } else {
          return done(null, identity, {
            scope: identity.get('scope')
          });
        }
      }));
      return passport.authenticate('bearer', {
        session: false
      });
    } else {
      return passport.authenticate('anonymous', {
        session: false
      });
    }
  };

  serializer = function(data) {
    var entry, _i, _len, _results;
    switch (false) {
      case !(data instanceof Array):
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          entry = data[_i];
          _results.push(serializer(entry));
        }
        return _results;
      case !(data instanceof DataStore.Model):
        return data.serialize(true);
      default:
        return data;
    }
  };

  poster = function(store, type) {
    return function() {
      var err, record, requestor;
      try {
        assert(store instanceof DataStore && (type != null) && (store.entities[type] != null) && (this.body[type] != null), "invalid POST request!");
      } catch (_error) {
        err = _error;
        return this.res.send(500, {
          error: err
        });
      }
      requestor = this.req.user;
      if (requestor == null) {
        return this.next();
      }
      try {
        record = store.createRecord(type, this.body[type]);
      } catch (_error) {
        err = _error;
        return this.res.send(500, {
          error: err
        });
      }
      return record.save((function(_this) {
        return function(err, props) {
          if (err != null) {
            return _this.res.send(500, {
              error: err
            });
          }
          if (props != null) {
            _this.req.result = record.serialize();
            return _this.next();
          } else {
            return _this.res.send(404);
          }
        };
      })(this));
    };
  };

  getter = function(store, type) {
    return function() {
      var condition, requestor, _ref, _ref1;
      requestor = this.req.user;
      condition = this.query.ids;
      if (condition == null) {
        condition = this.params.id;
      }
      if ((_ref = store.auditor) != null) {
        _ref.info({
          stormify: "getter",
          query: condition
        }, "stormify.getter for '" + type + "'");
      }
      if (!((requestor != null) && (type != null))) {
        return this.res.send(400);
      }
      if (condition !== void 0 && __indexOf.call((_ref1 = this.req.authInfo) != null ? _ref1.scope : void 0, 'all') < 0) {
        return this.res.send(403);
      }
      return store.find(type, condition, (function(_this) {
        return function(err, matches) {
          var o, _ref2;
          if (err != null) {
            return _this.res.send(500, {
              error: err
            });
          }
          if ((matches != null) && matches.length > 0) {
            o = {};
            o[type] = serializer(matches);
            _this.req.result = o;
            if ((_ref2 = store.auditor) != null) {
              _ref2.info({
                query: condition,
                result: _this.req.result
              }, 'getter results for %s', type);
            }
            return _this.next();
          } else {
            return _this.res.send(404);
          }
        };
      })(this));
    };
  };

  putter = function(store, type) {
    return function() {
      var requestor;
      requestor = this.req.user;
      if (!((requestor != null) && (type != null))) {
        return this.next();
      }
      return store.updateRecord(type, this.params.id, this.body, (function(_this) {
        return function(err, result) {
          var _ref;
          if (err != null) {
            return _this.res.send(500, {
              error: err
            });
          }
          if (result != null) {
            _this.req.result = result;
            if ((_ref = store.auditor) != null) {
              _ref.debug({
                query: _this.params.id,
                result: _this.req.result
              }, 'putter results for %s', type);
            }
            return _this.next();
          } else {
            return _this.res.send(404);
          }
        };
      })(this));
    };
  };

  remover = function(store, type) {
    return function() {
      var requestor;
      requestor = this.req.user;
      if (!((requestor != null) && (type != null))) {
        return this.next();
      }
      return store.deleteRecord(type, this.params.id, (function(_this) {
        return function(err, result) {
          var _ref;
          if (err != null) {
            return _this.res.send(500, {
              error: err
            });
          }
          if (result != null) {
            _this.req.result = result;
            if ((_ref = store.auditor) != null) {
              _ref.debug({
                query: _this.params.id,
                result: _this.req.result
              }, 'remover results for %s', type);
            }
            return _this.next();
          } else {
            return _this.res.send(404);
          }
        };
      })(this));
    };
  };

  module.exports = {
    DS: DataStore,
    authorizer: authorizer,
    poster: poster,
    getter: getter,
    putter: putter,
    remover: remover
  };

  module.exports.serve = function(store, opts) {
    var baseUrl, collection, entity, name, _ref, _ref1, _ref2, _ref3, _ref4, _results;
    assert((this.post != null) && (this.get != null) && (this.put != null) && (this.del != null), "cannot stormify.serve without CRUD operators present in the running context!");
    assert(store instanceof DataStore, "cannot stormify.serve without valid instance of DataStore!");
    if ((_ref = store.log) != null) {
      _ref.info({
        method: "serve"
      }, "STORMIFYING data entities!");
    }
    baseUrl = (opts != null ? opts.baseUrl : void 0) || '';
    _ref1 = store.entities;
    _results = [];
    for (name in _ref1) {
      entity = _ref1[name];
      if ((_ref2 = store.log) != null) {
        _ref2.debug({
          method: "serve"
        }, "processing " + name + "...");
      }
      if (entity.hidden) {
        continue;
      }
      if (entity.serve != null) {
        entity.serve.call(this, opts);
        if ((_ref3 = store.log) != null) {
          _ref3.info({
            method: "serve"
          }, "serving custom REST endpoint(s) for: " + name);
        }
        if (entity.serveOverride) {
          continue;
        }
      }
      collection = entity.collection;
      this.post("" + baseUrl + "/" + collection, authorizer(store), poster(store, name), function() {
        return this.send(this.req.result);
      });
      this.get("" + baseUrl + "/" + collection, authorizer(store), getter(store, name), function() {
        return this.send(this.req.result);
      });
      this.get("" + baseUrl + "/" + collection + "/:id", authorizer(store), getter(store, name), function() {
        return this.send(this.req.result);
      });
      this.put("" + baseUrl + "/" + collection + "/:id", authorizer(store), putter(store, name), function() {
        return this.send(this.req.result);
      });
      this.del("" + baseUrl + "/" + collection + "/:id", authorizer(store), remover(store, name), function() {
        return this.send(204);
      });
      _results.push((_ref4 = store.log) != null ? _ref4.info({
        method: "serve"
      }, "auto-generated REST endpoints at: " + baseUrl + "/" + name) : void 0);
    }
    return _results;
  };

}).call(this);
