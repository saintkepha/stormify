// Generated by CoffeeScript 1.8.0
(function() {
  var ComputedProperty, PropertyValidationError, StormClass, StormObject, StormProperty,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  StormClass = require('./storm-class');

  PropertyValidationError = (function(_super) {
    __extends(PropertyValidationError, _super);

    function PropertyValidationError() {
      return PropertyValidationError.__super__.constructor.apply(this, arguments);
    }

    return PropertyValidationError;

  })(Error);

  StormProperty = (function(_super) {
    __extends(StormProperty, _super);

    StormProperty.set({
      storm: 'property'
    });

    StormProperty.prototype.kind = 'attr';

    function StormProperty(type, opts, obj) {
      var _base, _base1;
      this.type = type;
      this.opts = opts != null ? opts : {};
      this.obj = obj;
      this.assert(this.obj instanceof StormObject, "cannot register a new property without a reference to an object it belongs to");
      if ((_base = this.opts).required == null) {
        _base.required = false;
      }
      if ((_base1 = this.opts).unique == null) {
        _base1.unique = false;
      }

      /**
       * @property value
       */
      this.value = void 0;

      /**
       * @property isDirty
       * @default false
       */
      this.isDirty = false;
    }

    StormProperty.prototype.get = function() {
      if (this.value instanceof StormProperty) {
        return this.value.get();
      } else {
        return this.value;
      }
    };

    StormProperty.prototype.set = function(value, opts) {
      var ArrayEquals, cval, nval;
      if (opts == null) {
        opts = {};
      }
      ArrayEquals = function(a, b) {
        return a.length === b.length && a.every(function(elem, i) {
          return elem === b[i];
        });
      };
      if (value == null) {
        value = (function() {
          switch (false) {
            case typeof this.opts.defaultValue !== 'function':
              return this.opts.defaultValue.call(this.obj);
            default:
              return this.opts.defaultValue;
          }
        }).call(this);
      }
      cval = this.value;
      nval = this.normalize(value);
      if (nval instanceof Array && nval.length > 0) {
        nval = nval.filter(function(e) {
          return e != null;
        });
        if (this.opts.unique === true) {
          nval = nval.unique();
        }
      }
      if (!(opts.skipValidation === true || this.validate(nval))) {
        return new PropertyValidationError(nval);
      }
      this.isDirty = (function() {
        switch (false) {
          case !((cval == null) && (nval != null)):
            return true;
          case this.type !== 'array':
            return !ArrayEquals(cval, nval);
          case cval !== nval:
            return false;
          default:
            return true;
        }
      }).call(this);
      if (this.isDirty === true) {
        this.value = nval;
      }
      return this;
    };

    StormProperty.prototype.validate = function(value) {
      if (value == null) {
        value = this.value;
      }
      if (typeof this.opts.validator === 'function') {
        return this.opts.validator.call(this.obj, value);
      }
      if (value == null) {
        return this.opts.required === false;
      }
      if (value instanceof StormProperty) {
        value = value.get();
      }
      switch (this.type) {
        case 'string' || 'number' || 'boolean' || 'object':
          return typeof value === this.type;
        case 'date':
          return value instanceof Date;
        case 'array':
          return value instanceof Array;
        default:
          return true;
      }
    };

    StormProperty.prototype.normalize = function(value) {
      switch (false) {
        case !(value instanceof Object && typeof value.stormify === 'function'):
          return value.stormify.call(this.obj);
        case !(this.type === 'date' && typeof value === 'string'):
          return new Date(value);
        case !(this.type === 'array' && !(value instanceof Array)):
          if (value != null) {
            return [value];
          } else {
            return [];
          }
          break;
        default:
          return value;
      }
    };

    StormProperty.prototype.serialize = function(format) {
      if (format == null) {
        format = 'json';
      }
      switch (false) {
        case typeof this.opts.serializer !== 'function':
          return this.opts.serializer.call(this.obj, this.value, format);
        case !(this.value instanceof StormProperty):
          return this.value.serialize(format);
        default:
          return this.value;
      }
    };

    return StormProperty;

  })(StormClass);

  ComputedProperty = (function(_super) {
    __extends(ComputedProperty, _super);

    ComputedProperty.set({
      storm: 'computed'
    });

    ComputedProperty.prototype.kind = 'computed';


    /**
     * @property func
     * @default null
     */

    ComputedProperty.func = function() {
      return null;
    };

    function ComputedProperty(func, opts, obj) {
      var type, _ref, _ref1;
      this.func = func;
      if (opts == null) {
        opts = {};
      }
      console.log('computed');
      console.log(this.func);
      this.assert(typeof this.func === 'function', "cannot register a new ComputedProperty without a function");
      type = (_ref = opts.type) != null ? _ref : 'computed';
      ComputedProperty.__super__.constructor.call(this, type, opts, obj);
      this.cache = (_ref1 = opts.cache) != null ? _ref1 : 0;
      if (this.cache > 0) {
        this.cachedOn = new Date();
      }
    }

    ComputedProperty.prototype.isCachedValid = function() {
      return this.cache > 0 && (new Date() - this.cachedOn) / 1000 < this.cache;
    };

    ComputedProperty.prototype.get = function() {
      if (!((this.value != null) && this.isCachedValid())) {
        this.set(this.func.call(this.obj));
        if (this.cache > 0) {
          this.cachedOn = new Date();
        }
      }
      return ComputedProperty.__super__.get.apply(this, arguments);
    };

    ComputedProperty.prototype.serialize = function() {
      return ComputedProperty.__super__.serialize.call(this, this.get());
    };

    return ComputedProperty;

  })(StormProperty);

  StormObject = (function(_super) {
    __extends(StormObject, _super);

    StormObject.set({
      storm: 'object'
    });

    StormObject.attr = function(type, opts) {
      return (function(_super1) {
        __extends(_Class, _super1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: type,
          opts: opts
        });

        return _Class;

      })(StormProperty);
    };

    StormObject.computed = function(func, opts) {
      return (function(_super1) {
        __extends(_Class, _super1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set({
          type: func,
          opts: opts
        });

        return _Class;

      })(ComputedProperty);
    };

    StormObject.Property = StormProperty;

    StormObject.ComputedProperty = ComputedProperty;

    function StormObject(data, opts) {
      var key, val, _ref;
      this.opts = opts != null ? opts : {};
      this._properties = {};
      for (key in this) {
        val = this[key];
        if (key !== 'constructor' && (((_ref = val.meta) != null ? _ref.storm : void 0) != null)) {
          this.addProperty(key, new val(val.get('type'), val.get('opts'), this));
        }
      }
      this.everyProperty(function(key) {
        return this.set(void 0, {
          skipValidation: true
        });
      });
      if (data != null) {
        this.set(data, {
          skipValidation: true
        });
      }
    }

    StormObject.prototype.keys = function() {
      return Object.keys(this._properties);
    };

    StormObject.prototype.addProperty = function(key, property) {
      if (!(this.hasProperty(key)) && property instanceof StormClass) {
        this._properties[key] = property;
      }
      return property;
    };

    StormObject.prototype.removeProperty = function(key) {
      if (this.hasProperty(key)) {
        return delete this._properties[key];
      }
    };

    StormObject.prototype.hasProperty = function(key) {
      return this._properties.hasOwnProperty(key);
    };


    /**
     * `getProperty` supports retrieving property based on composite key such as:
     * 'hello.world.bye'
     *
     * Since this routine is the primary function for get/set operations,
     * you can also use it to specify nested path during those operations.
     */

    StormObject.prototype.getProperty = function(key) {
      var composite, prop, _i, _len;
      composite = key.split('.');
      key = composite.shift();
      if (this.hasProperty(key)) {
        prop = this._properties[key];
      }
      for (_i = 0, _len = composite.length; _i < _len; _i++) {
        key = composite[_i];
        if (prop == null) {
          return;
        }
        prop = typeof prop.getProperty === "function" ? prop.getProperty(key) : void 0;
      }
      return prop;
    };

    StormObject.prototype.get = function() {
      var key, keys, result, _i, _len, _ref, _ref1;
      keys = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = {};
      switch (false) {
        case keys.length !== 0:
          this.everyProperty(function(key) {
            return result[key] = this.get();
          });
          break;
        case keys.length !== 1:
          result = (_ref = this.getProperty(keys[0])) != null ? _ref.get() : void 0;
          break;
        default:
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            key = keys[_i];
            result[key] = (_ref1 = this.getProperty(key)) != null ? _ref1.get() : void 0;
          }
      }
      return result;
    };


    /**
     * `set` is used to place values on matching StormProperty
     * instances. Accepts an object of key/values
     *
     * obj.set hello:'world'
     *
     * { hello: 'world' }
     *
     * obj.set test:'a', sample:'b'
     *
     * obj.set 'test.nested.param':'a', sample:'b'
     *
     * also takes in `opts` as an optional param object to override
     * validations and other special considerations during the `set`
     * execution.
     */

    StormObject.prototype.set = function(obj, opts) {
      var key, value, _ref;
      if (!(obj instanceof Object)) {
        return;
      }
      for (key in obj) {
        value = obj[key];
        if ((_ref = this.getProperty(key)) != null) {
          _ref.set(value, opts);
        }
      }
      return this;
    };

    StormObject.prototype.everyProperty = function(func) {
      var key, prop, _ref, _results;
      _ref = this._properties;
      _results = [];
      for (key in _ref) {
        prop = _ref[key];
        _results.push(func != null ? func.call(prop, key) : void 0);
      }
      return _results;
    };

    StormObject.prototype.validate = function() {
      return (this.everyProperty(function(key) {
        return {
          name: key,
          isValid: this.validate()
        };
      })).filter(function(e) {
        return e.isValid === false;
      });
    };

    StormObject.prototype.serialize = function(format) {
      var o;
      if (format == null) {
        format = 'json';
      }
      o = (function() {
        switch (format) {
          case 'json':
            return {};
          default:
            return '';
        }
      })();
      this.everyProperty(function(key) {
        switch (format) {
          case 'json':
            return o[key] = this.serialize(format);
          case 'xml':
            return o += ("<" + key + ">") + (this.serialize(format)) + ("</" + key + ">");
        }
      });
      return o;
    };

    StormObject.prototype.clearDirty = function() {
      return this.everyProperty(function() {
        return this.isDirty = false;
      });
    };

    StormObject.prototype.dirtyProperties = function(keys) {
      return (this.everyProperty(function(key) {
        var _ref;
        return (_ref = this.isDirty) != null ? _ref : key;
      })).filter(function(x) {
        if (keys != null) {
          return (x != null) && __indexOf.call(keys, x) >= 0;
        } else {
          return x != null;
        }
      });
    };

    StormObject.prototype.isDirty = function(keys) {
      if ((keys != null) && !(keys instanceof Array)) {
        keys = [keys];
      }
      return (this.dirtyProperties(keys)).length > 0;

      /* for future optimization reference
      dirty = @dirtyProperties().join ' '
      keys.some (prop) -> ~dirty.indexOf prop
       */
    };

    return StormObject;

  })(StormClass);

  module.exports = StormObject;

}).call(this);
