// Generated by CoffeeScript 1.8.0
(function() {
  var YangGenerator, YangModel, assert,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  assert = require('assert');

  YangModel = require('./yang-model');

  YangGenerator = (function() {
    var YangParser, spec;

    spec = require('./yang-generator-map');

    YangParser = require('yang-parser');

    function YangGenerator(parser) {
      this.parser = parser != null ? parser : YangParser;
      this;
    }

    YangGenerator.prototype.generate = function(schema, map) {
      var generator, statement;
      this.map = map != null ? map : spec;
      assert((schema != null) && typeof schema === 'string', "must pass in input schema text to process for YANG");
      statement = this.parser.parse(schema);
      assert((statement != null) && statement.kw === 'module', "must pass in YANG module schema definition");
      this.groupings = {};
      generator = this;
      return (function(_super) {
        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.extend({
          meta: {
            name: statement.arg,
            schema: schema
          }
        });

        _Class.include(generator._process(statement));

        return _Class;

      })(YangModel);
    };

    YangGenerator.prototype["import"] = function(module, opts) {
      return null;
    };

    YangGenerator.prototype.include = function(module, opts) {
      return null;
    };

    YangGenerator.prototype.resolve = function(grouping, opts) {
      if (!this.groupings.hasOwnProperty(grouping)) {
        console.log("WARNING: trying to 'uses' using " + grouping + " identifier not found");
        return null;
      }
      return (function(_super) {
        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.include(opts);

        return _Class;

      })(this.groupings[grouping]);
    };

    YangGenerator.prototype._resolveMap = function(map, key) {
      var v, value, _ref;
      value = (_ref = map[key]) != null ? _ref : this.map[key];
      switch (false) {
        case !(value instanceof Function):
          return value();
        case !(value instanceof Array):
          v = value[0];
          v = (function() {
            switch (false) {
              case !(v instanceof Function):
                return v();
              default:
                return v;
            }
          })();
          return {
            type: 'array',
            value: v
          };
        default:
          return value;
      }
    };

    YangGenerator.prototype._process = function(statement, map, context) {
      var group, hasMany, keyword, param, properties, results, subs, substatement;
      if (map == null) {
        map = this.map;
      }
      keyword = statement.kw, param = statement.arg, subs = statement.substmts;
      map = this._resolveMap(map, keyword);
      if ((map != null ? map.type : void 0) === 'array') {
        hasMany = true;
        map = map.value;
      }
      if (map == null) {
        console.log("WARNING: unsupported YANG " + keyword + " found for " + context);
        return;
      }
      results = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = subs.length; _i < _len; _i++) {
          substatement = subs[_i];
          _results.push(this._process(substatement, map, statement));
        }
        return _results;
      }).call(this);
      if (results.length > 0) {
        properties = (results.filter(function(e) {
          return e != null;
        })).reduce((function(a, b) {
          a[b.name] = b.value;
          return a;
        }), {});
      }
      switch (keyword) {
        case 'module':
        case 'submodule':
          return properties;
        case 'import':
          return this["import"](param, properties);
        case 'include':
          return this.include(param, properties);
        case 'uses':
          return {
            name: param,
            value: this.resolve(param, properties)
          };
        case 'typedef':
          return null;
        case 'extension':
          return {
            name: param,
            value: (function(_super) {
              __extends(_Class, _super);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              _Class.extend(properties);

              return _Class;

            })(YangModel.Extension)
          };
        case 'grouping':
          group = (function(_super) {
            __extends(_Class, _super);

            function _Class() {
              return _Class.__super__.constructor.apply(this, arguments);
            }

            _Class.extend({
              meta: {
                name: "" + _Class['module-name'] + ":" + param
              }
            });

            _Class.include(properties);

            return _Class;

          })(YangModel.Grouping);
          this.groups[param] = group;
          return {
            name: param,
            value: group
          };
        case 'container':
          return {
            name: param,
            value: (function(_super) {
              __extends(_Class, _super);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              _Class.include(properties);

              return _Class;

            })(YangModel.Container)
          };
        case 'list':
          return {
            name: param,
            value: (function(_super) {
              __extends(_Class, _super);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              _Class.extend({
                type: (function(_super1) {
                  __extends(_Class, _super1);

                  function _Class() {
                    return _Class.__super__.constructor.apply(this, arguments);
                  }

                  _Class.include(properties);

                  return _Class;

                })(YangModel.List.Entry),
                opts: properties
              });

              return _Class;

            })(YangModel.List)
          };
        case 'revision':
          properties.defaultValue = param;
          return {
            name: keyword,
            value: (function(_super) {
              __extends(_Class, _super);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              _Class.extend({
                opts: properties
              });

              return _Class;

            })(YangModel.Property)
          };
        case 'rpc':
          return null;
        default:
          if (properties != null) {
            return {
              name: param,
              value: (function(_super) {
                __extends(_Class, _super);

                function _Class() {
                  return _Class.__super__.constructor.apply(this, arguments);
                }

                _Class.extend({
                  type: properties.type,
                  opts: properties
                });

                return _Class;

              })(YangModel.Property)
            };
          } else {
            return {
              name: keyword,
              value: param
            };
          }
      }
    };

    return YangGenerator;

  })();

  module.exports = YangGenerator;

}).call(this);
