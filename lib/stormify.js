// Generated by CoffeeScript 1.8.0
(function() {
  var AnonymousStrategy, BearerStrategy, DataStorm, authorizer, passport;

  DataStorm = require('./data-storm');

  passport = require('passport');

  BearerStrategy = require('passport-http-bearer');

  AnonymousStrategy = require('passport-anonymous');

  passport.use(new AnonymousStrategy);

  authorizer = function(store) {
    if ((store.authorizer != null) && store.authorizer instanceof DataStorm) {
      passport.use(new BearerStrategy(function(token, done) {
        var identity, session;
        token = store.authorizer.findRecord('token', token);
        if ((token != null) && token instanceof DataStorm.Model) {
          identity = token.get('identity');
          session = token.get('session');
          if ((identity != null) && (session != null)) {
            return done(null, session, {
              scope: identity.get('scope')
            });
          }
        }
        return done(null, false);
      }));
      return passport.authenticate('bearer', {
        session: false
      });
    } else {
      return passport.authenticate('anonymous', {
        session: false
      });
    }
  };

  module.exports.DS = DataStorm;

  module.exports.express = function(ds) {
    var app, assert, bp, router, serializer;
    assert = require('assert');
    assert(ds instanceof DataStorm, 'cannot express without valid DataStorm passed-in');
    app = (require('express'))();
    bp = require('body-parser');
    app.use(bp.urlencoded({
      extended: true
    }), bp.json({
      strict: true
    }), (require('passport')).initialize());
    app.set({
      'json spaces': 2
    });
    authorizer = function(storm) {
      return function(req, res, next) {
        return next();
      };
    };
    serializer = function(data) {
      var entry, _i, _len, _results;
      switch (false) {
        case !(data instanceof Array):
          _results = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            entry = data[_i];
            _results.push(serializer(entry));
          }
          return _results;
        case !(data instanceof DataStorm.Model):
          return data.serialize();
        default:
          return data;
      }
    };
    router = (require('express')).Router();
    router.param('collection', function(req, res, next, collection) {
      req.collection = req.storm.contains(collection);
      if (req.collection != null) {
        return next();
      } else {
        return next('route');
      }
    });
    router.param('id', function(req, res, next, id) {
      assert(req.collection != null, "cannot retrieve '" + id + "' without a valid collection!");
      req.record = req.collection.match(id);
      if (req.record != null) {
        return next();
      } else {
        return next('route');
      }
    });
    router.param('action', function(req, res, next, action) {
      assert(req.record != null, "cannot perform '" + action + "' without a record to operate on!");
      req.action = req.record.invoke(action, req.query, req.body);
      if (req.action != null) {
        return next();
      } else {
        return next('route');
      }
    });
    router.all('*', authorizer(ds), function(req, res, next) {
      req.storm = ds;
      return next();
    });
    router.route("/").all(function(req, res, next) {
      return next();
    }).get(function(req, res, next) {
      res.locals.result = req.storm.serialize();
      return next();
    }).post(function(req, res, next) {
      return next();
    }).copy(function(req, res, next) {
      return next();
    });
    router.use(function(req, res, next) {
      if (res.locals.result == null) {
        return next('route');
      }
      res.setHeader('Expires', '-1');
      res.send(res.locals.result);
      return next();
    });
    app.use(router);
    return app;
    router.route("" + ds.name + "/:collection").all(function(req, res, next) {
      return next();
    }).get(function(req, res, next) {
      res.locals.result = req.collection.serialize();
      return next();
    }).put(function(req, res, next) {
      assert((req.body != null) && req.body.hasOwnProperty(req.collection.name, "attempting to PUT without proper '" + req.collection.name + "' as root element"));
      req.collection.update(req.body[req.collection.name]);
      return req.collection.save(function(err, result) {
        if (err) {
          return next(err);
        }
        res.locals.result = this.serialize();
        return next();
      });
    }).copy(function(req, res, next) {
      res.locals.result = req.collection.registry.list();
      return next();
    }).merge(function(req, res, next) {
      assert((req.body != null) && req.body.hasOwnProperty(req.collection.modelName, "attempting to MERGE without proper '" + req.collection.modelName + " as root element"));
      req.collection.registry.merge(req.body[req.collection.modelName]);
      return next();
    }).subscribe(function(req, res, next) {
      var callback, checksum;
      checksum = req.body;
      if (!req.collection.subscribers.hasOwnProperty(checksum)) {
        req.collection.subscribers[checksum] = {
          event: req.body.event,
          callback: callback = function(record) {
            return request({
              url: req.body.url,
              method: 'notify',
              body: {
                id: checksum,
                data: record.serialize()
              }
            });
          }
        };
        req.collection.on(req.body.event, callback);
      }
      res.locals.result = {
        id: checksum
      };
      return next();
    }).unsubscribe(function(req, res, next) {
      var subscription;
      subscription = req.collection.subscribers[req.body.id];
      if (subscription != null) {
        req.collection.removeListener(subscription.event, subscription.callback);
      }
      return next();
    });
    router.route(':collection').all(function(req, res, next) {
      return next();
    }).get(function(req, res, next) {
      var condition;
      condition = req.query.ids;
      if (Object.keys(req.query).length !== 0) {
        if (condition == null) {
          condition = req.query;
        }
      }
      return req.collection.find(condition, function(err, matches) {
        if (err) {
          return next(err);
        }
        res.locals.result = serializer(matches);
        return next();
      });
    }).post(function(req, res, next) {
      var payload, record;
      assert((req.body != null) && req.body.hasOwnProperty(req.collection.modelName, "attempting to POST without proper '" + req.collection.modelName + "' as root element!"));
      payload = req.body[req.collection.modelName];
      if (payload instanceof Array) {
        return next(new Error("bulk POST not yet implemented!"));
      }
      record = req.storm.createRecord(req.collection.modelName, payload);
      return record.save(function(err, result) {
        if (err) {
          return next(err);
        }
        res.locals.result = this.serialize();
        return next();
      });
    }).head(function(req, res, next) {
      res.locals.result = 'some-checksum';
      return next();
    });
    router.route(':collection/:id').all(function(req, res, next) {
      return next();
    }).get(function(req, res, next) {
      res.locals.result = req.record.serialize();
      return next();
    }).put(function(req, res, next) {
      assert((req.body != null) && req.body.hasOwnProperty(req.record.name, "attempting to PUT without proper '" + req.record.name + "' as root element!"));
      req.record.update(req.body[req.record.name]);
      return req.record.save(function(err, result) {
        if (err) {
          return next(err);
        }
        res.locals.result = this.serialize();
        return next();
      });
    })["delete"](function(req, res, next) {
      return req.record.destroy(function(err, result) {
        if (err) {
          return next(err);
        }
        res.locals.result = result;
        return next();
      });
    });
    router.route(":collection/:id/:action").post(function(req, res, next) {
      return req.action.then((function(response) {
        res.locals.result = response;
        return next();
      }, function(error) {
        return next(error);
      }));
    });
    router.use(function(req, res, next) {
      var o;
      if (res.locals.result == null) {
        return next('route');
      }
      res.setHeader('Expires', '-1');
      o = {};
      o[req.collection.modelName] = res.locals.result;
      res.send(o);
      return next();
    });
    router.use(function(req, res, next) {
      var _ref;
      if ((_ref = req.storm.log) != null) {
        _ref.info({
          query: req.params.id,
          result: res.locals.result
        }, 'PUT results for %s', req.record.name);
      }
      return next();
    });
    router.use(function(err, req, res, next) {
      return res.status(500).send({
        error: err
      });
    });
    app.use(router);
    return app;
  };

  module.exports.serve = function(store, opts) {
    var action, baseUrl, collection, entity, name, _fn, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
    if (this.del == null) {
      this.del = this["delete"];
    }
    assert((this.post != null) && (this.get != null) && (this.put != null) && (this.del != null), "cannot stormify.serve without CRUD operators present in the running context!");
    assert(store instanceof DataStore, "cannot stormify.serve without valid instance of DataStore!");
    if ((_ref = store.log) != null) {
      _ref.info({
        method: "serve"
      }, "STORMIFYING data entities!");
    }
    baseUrl = (opts != null ? opts.baseUrl : void 0) || '';
    _ref1 = store.collections;
    _results = [];
    for (collection in _ref1) {
      entity = _ref1[collection];
      if ((_ref2 = store.log) != null) {
        _ref2.debug({
          method: "serve"
        }, "processing " + collection + "...");
      }
      if (entity.hidden) {
        continue;
      }
      if (entity.serve != null) {
        entity.serve.call(this, opts);
        if ((_ref3 = store.log) != null) {
          _ref3.info({
            method: "serve"
          }, "serving custom REST endpoint(s) for: " + collection);
        }
        if (entity.serveOverride) {
          continue;
        }
      }
      name = entity.name;
      this.get("" + baseUrl + "/" + collection, authorizer(store), getter(store, name), function() {
        return this.send(this.res.locals.result);
      });
      this.get("" + baseUrl + "/" + collection + "/:id", authorizer(store), getter(store, name), function() {
        return this.send(this.res.locals.result);
      });
      if (!(entity.isReadOnly || entity.persist === false)) {
        this.post("" + baseUrl + "/" + collection, authorizer(store), poster(store, name), function() {
          return this.send(this.res.locals.result);
        });
        this.put("" + baseUrl + "/" + collection + "/:id", authorizer(store), putter(store, name), function() {
          return this.send(this.res.locals.result);
        });
        this.del("" + baseUrl + "/" + collection + "/:id", authorizer(store), remover(store, name), function() {
          return this.res.status(204).send();
        });
        _fn = (function(_this) {
          return function(action) {
            var _ref5;
            if ((_ref5 = store.log) != null) {
              _ref5.info({
                method: "serve"
              }, "exposing actions: " + baseUrl + "/" + collection + "/:id/" + action);
            }
            return _this.post("" + baseUrl + "/" + collection + "/:id/" + action, authorizer(store), getter(store, name), function() {
              var record;
              record = this.res.locals.matches[0];
              return record.invoke(action, this.req.query, this.req.body).then((function(_this) {
                return function(response) {
                  return _this.send(response);
                };
              })(this), (function(_this) {
                return function(error) {
                  return _this.res.status(500).send({
                    error: error
                  });
                };
              })(this));
            });
          };
        })(this);
        for (action in (_ref4 = entity.controller) != null ? _ref4.prototype.actions : void 0) {
          _fn(action);
        }
      }
      _results.push((_ref5 = store.log) != null ? _ref5.info({
        method: "serve"
      }, "auto-generated REST endpoints at: " + baseUrl + "/" + collection) : void 0);
    }
    return _results;
  };

}).call(this);
